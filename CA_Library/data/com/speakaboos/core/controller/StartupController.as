package com.speakaboos.core.controller{	import com.greensock.TweenLite;	import com.greensock.TweenMax;	import com.speakaboos.ane.ANEController;	import com.speakaboos.core.anx.AnxController;	import com.speakaboos.core.events.AppEvents;	import com.speakaboos.core.events.CoreEventDispatcher;	import com.speakaboos.core.events.GenericDataEvent;	import com.speakaboos.core.events.ModalEvents;	import com.speakaboos.core.models.data.KyowonUser;	import com.speakaboos.core.models.data.ModalsInfo;	import com.speakaboos.core.models.impl.UserProfileImpl;	import com.speakaboos.core.models.services.CacheDataService;	import com.speakaboos.core.models.services.LoginService;	import com.speakaboos.core.models.services.NetworkMonitor;	import com.speakaboos.core.models.services.PreloadService;	import com.speakaboos.core.models.services.SpeakaboosService;	import com.speakaboos.core.models.services.StoreKitService;	import com.speakaboos.core.models.services.StoryDbService;	import com.speakaboos.core.models.services.SubscriptionService;	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.core.utils.HtmlTextUtil;	import com.speakaboos.core.utils.MathUtils;	import com.speakaboos.core.utils.SocialUtils;	import com.speakaboos.core.view.BookView;	import com.speakaboos.core.view.holders.CoreMovieClipHolder;	import com.speakaboos.core.view.holders.components.ProgressBar;	import com.speakaboos.core.view.holders.components.SbProgressBar;	import com.speakaboos.mobile.data.dao.AnxDbCreator;	import com.speakaboos.mobile.data.dao.DbCreator;	import com.speakaboos.story.events.AnalyticsEvent;	import com.speakaboos.story.events.CentralEventDispatcher;	import com.speakaboos.story.events.StoryEvent;	import com.speakaboos.story.model.vo.AnalyticsEventVO;	import com.speakaboos.story.utils.FileUtils;	import com.speakaboos.story.utils.SystemUtils;		import flash.desktop.NativeApplication;	import flash.desktop.SystemIdleMode;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.InvokeEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Keyboard;		public class StartupController extends CoreMovieClipHolder	{		//		private var _videoPlayer:VideoPlayer;				private var _appController:AppController;				private static const TITLE_ANIM_DONE_LABEL:String = "titleAnimDone";		private static const TITLE_ANIM_OPEN_LABEL:String = "openBook";		private var _titleAnimDoneFrame:int;		private var _titleAnimOpenFrame:int;		private var _titleAnimEndFrame:int;				private var _introAnim:MovieClip;		private var _progBar:SbProgressBar;		private var _preloader:PreloadService;		private static var _skipIntro:Boolean = false;		private static var _updateAvailable:Boolean = false;		private static var MIN_UPDATE_CHECK_TIME:Number = 1000 * 60 * 60 * 24; //last number is hours, 24 for a day between update checks.		private static var MIN_IN_BACKGROUND_CHECK_TIME:Number = 1000 * 60 * 60 * 1; // min time in background before move to forground will trigger update		private static var _resetPending:Boolean = false;		private static var _lastBackgroundTime:Number;		private var _introAnimFinished:Boolean;				private var _aneController:ANEController;		//		public static var spkANE:SpeakaboosANE;		//		private var _aneContext:ExtensionContext;						public static var introFinished:Boolean = false;				public function StartupController(pMc:MovieClip) {			super(pMc);			trace("[ StartupController ] (pMc) airVersion:" +AppConfig.airVersion);						FileUtils.init();			init();		}						private function init():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"init()"); }			if (AppConfig.DEBUG_MODE) {				MIN_UPDATE_CHECK_TIME = 2 * 60 * 1000; ///set update check to 2 min for testing				MIN_IN_BACKGROUND_CHECK_TIME = 0.2 * 60 * 1000; // set min in backgound before update trigger = 12 sec for testing			}						initANE();						HtmlTextUtil.init();			addListeners();			NetworkMonitor.getInstance();			_appController = AppController.getInstance();			mc.parent.addChild(_appController);						start();		}				private function addListeners():void {			CONFIG::ANDROID {				if (SystemUtils.isAndroidDevice()) {					NativeApplication.nativeApplication.addEventListener(InvokeEvent.INVOKE,onInvoke);					NativeApplication.nativeApplication.addEventListener(Event.ACTIVATE, handleActivate, false, 0, true);					NativeApplication.nativeApplication.addEventListener(Event.DEACTIVATE, handleDeactivate, false, 0, true);					NativeApplication.nativeApplication.addEventListener(KeyboardEvent.KEY_DOWN, handleKeys, false, 0, true);				}			}							addEventListener( Event.ACTIVATE, onAppInForeground );			addEventListener( Event.DEACTIVATE, onAppInBackground);		}				private function removeListeners():void {			CONFIG::ANDROID {				if (SystemUtils.isAndroidDevice()) {					NativeApplication.nativeApplication.removeEventListener(InvokeEvent.INVOKE,onInvoke);					NativeApplication.nativeApplication.removeEventListener(Event.ACTIVATE, handleActivate);					NativeApplication.nativeApplication.removeEventListener(Event.DEACTIVATE, handleDeactivate);					NativeApplication.nativeApplication.removeEventListener(KeyboardEvent.KEY_DOWN, handleKeys);				}			}							removeEventListener( Event.ACTIVATE, onAppInForeground );			removeEventListener( Event.DEACTIVATE, onAppInBackground);		}				private function start():void {			_introAnimFinished = false;			initAnim();		}				/*********************************************************************		 * @category ANIMATION		 *********************************************************************/				private function initAnim():void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"initAnim()"); }						AnxController.getInstance().sendData(new AnalyticsEventVO({screen:AnalyticsEvent.EVENT_SCREEN_INTRO}));						CONFIG::NOTKYOWON {				killIntroAnim();				_introAnim = new IntroAnimation();				_introAnim.x = Main.STAGE_WIDTH/2;				_introAnim.y = Main.STAGE_HEIGHT/2;				_introAnim.gotoAndStop(TITLE_ANIM_DONE_LABEL);				_titleAnimDoneFrame = _introAnim.currentFrame;				_introAnim.gotoAndStop(TITLE_ANIM_OPEN_LABEL);				_titleAnimOpenFrame = _introAnim.currentFrame;				_titleAnimEndFrame = _introAnim.totalFrames;								CONFIG::DEBUG{ trace("[ StartupController ] "+"initAnim() "+_titleAnimDoneFrame+", "+_titleAnimOpenFrame+", "+_titleAnimEndFrame+", "); }								_introAnim.gotoAndStop(1);				_introAnim.addFrameScript(_titleAnimDoneFrame, initPreload);				_introAnim.addFrameScript(_titleAnimOpenFrame - 1, animFinished);				_introAnim.addFrameScript(_titleAnimEndFrame - 1, showController);				addChild(_introAnim);				if (_skipIntro) {					skipIntro();				} else {					_introAnim.play();					_introAnim.addEventListener(MouseEvent.MOUSE_DOWN, skipIntro);				}			}							CONFIG::KYOWON {				_introAnimFinished = true;				_introAnim = new KyowonBookOpening();				_introAnim.x = Main.STAGE_WIDTH/2;				_introAnim.y = Main.STAGE_HEIGHT/2;				_introAnim.gotoAndStop(1);				_titleAnimEndFrame = _introAnim.totalFrames;				_introAnim.addFrameScript(_titleAnimEndFrame - 1, showController);				addChild(_introAnim);				initPreload();				showProgBar();				checkPreloader();			}		}				private function animFinished(e:MouseEvent=null):void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"animFinished(e)"); }						_introAnim.removeEventListener(MouseEvent.MOUSE_DOWN, skipIntro);			_introAnimFinished = true;			_introAnim.gotoAndStop(_titleAnimOpenFrame);						if (_progBar.progress < 1) {				showProgBar();				checkPreloader();			} else {				checkIntroDone();			}		}				private function showController():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"showController(e)"); }						if (_introAnim) _introAnim.stop();			removeProgBar();						_appController.initBook();			_appController.startOpenBook();			killIntroAnim();		}				private function skipIntro(e:MouseEvent = null):void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"skipIntro"); }			initPreload();			animFinished();		}						private function checkIntroDone():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"checkIntroDone"); }			var showVid:Boolean;						if (_introAnimFinished) {				CONFIG::KYOWON {					showVid = false;				}									CONFIG::NOTKYOWON {					showVid = (SpeakaboosService.getInstance().savedStoryCount == 0);				}									//showVid = false;				_introAnim.gotoAndStop(_titleAnimOpenFrame);								if (showVid) {					playWelcomeVideo();				} else {					TweenMax.delayedCall(0.1, playOpenBookAnim); // allow the complete prog bar to be seen				}								introFinished = true;			}		}						private function playWelcomeVideo():void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"playWelcomeVideo()"); }						CentralEventDispatcher.getInstance().addEventListener(StoryEvent.VIDEO_ENDED, welcomeVideoFinished);			_appController.playWelcomeVideo();			TweenMax.delayedCall(0.2, removeProgBar);		}				private function welcomeVideoFinished(e:Event = null):void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"welcomeVideoFinished(e)"); }						CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.VIDEO_ENDED, welcomeVideoFinished);			playOpenBookAnim();		}				private function playOpenBookAnim(e:GenericDataEvent = null):void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"playOpenBookAnim(e) 1"); }						_introAnim.play();			removeProgBar();		}				private function killIntroAnim():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"killIntroAnim()"); }						if (_introAnim) {				_introAnim.gotoAndStop(1);				removeChild(_introAnim);				_introAnim = null;			}		}								/*********************************************************************		 * @category PRELOADING		 *********************************************************************/						private function checkPreloader():void {			if (CoreEventDispatcher.getInstance().hasEventListener(AppEvents.PRELOAD_COMPLETE)) {				if (_preloader) _preloader.resumePreload();			}		}				private function initPreload():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"initPreload()"); }			_progBar = new SbProgressBar();			incrementTotal(SbProgressBar.DB_VERIFICATION_PROG_INDEX, 1);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.PRELOAD_COMPLETE, preloadComplete);							// this is being done here because, since it is async, it might not finish before preload is done, even though it was always initiated in this class...			var dbc:DbCreator = new DbCreator();			dbc.createDatabase(createAnxDb);		}						private function showProgBar():void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"showProgBar()"); }						if (!contains(_progBar) && (_progBar.progress < 1)) {				addChild(_progBar);								_progBar.mc.x = (Main.STAGE_WIDTH/2) - (_progBar.mc.width/2) + 17;				_progBar.mc.y = 500;			}		}						private function removeProgBar():void {			if (_progBar) {				removeChild(_progBar.view);				_progBar.destroy();				_progBar = null;			}		}				protected function preloadComplete(event:GenericDataEvent):void {			CONFIG::DEBUG{ trace("[ StartupController ] "+"preloadComplete(event)"); }						// either the animation is still going, so we let that finish, else go onto the main menu			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.PRELOAD_COMPLETE, preloadComplete);						if (_preloader) {				_preloader.destroy();				_preloader = null;			}						incrementProgress(SbProgressBar.UPDATE_SAVED_INDEX, 1);						CONFIG::DEBUG{				_progBar.__logProg();				CONFIG::DEBUG{ trace("[ StartupController ] "+"preloadComplete(event) progress:"+_progBar.progress); }			}						NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.NORMAL;						checkIntroDone();		}				public static function incrementProgress(index:int, val:int):void {			trace("[ StartupController ] incrementProgress() index: "+index+", value: "+val);			if (val > 0) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ProgressBar.UPDATE_PROGRESS, {index:index, type:ProgressBar.COMPLETED_TYPE, val:val, increment:true}));			}		}				public static function incrementTotal(index:int, val:int):void {			if (val > 0) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ProgressBar.UPDATE_PROGRESS, {index:index, type:ProgressBar.TOTAL_TYPE, val:val, increment:true}));			}		}				/*********************************************************************		 * @category DATABASE		 *********************************************************************/				private function createAnxDb(success:Boolean):void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"Main Db Created(" + success + ")"); }			CONFIG::DEBUG{ trace("[ StartupController ] "+"Creating Anx Db"); }						var anxDbc:AnxDbCreator = new AnxDbCreator();			anxDbc.createDatabase(onDbCreated);		}				private function onDbCreated(success:Boolean):void { 			CONFIG::DEBUG{ trace("[ StartupController ] "+"onDbCreated(" + success + ")"); }						//TODO: handle failure (was not checking this when in AppController either			StoryDbService.getInstance(); //init db instance, but don't need the instance here			incrementProgress(SbProgressBar.DB_VERIFICATION_PROG_INDEX, 1);			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;			CONFIG::KYOWON {				CONFIG::SIGNED_IN {					fakeKyowonAuth();					return;				}									if (SystemUtils.isAndroidDevice()){										CONFIG::DEBUG{ trace("[ StartupController ] "+"get kyowon user info from ane before start()"); }										//CONFIG::DEBUG{ trace("[ StartupController ] "+"*** START TIMEOUT TIMER"); }										//IF APP HASN'T RECEIVED AUTHORIZATION WITHIN 10 SECONDS, APP WILL QUIT					//if (!UserProfileImpl.getInstance().kyowonUser) TweenLite.delayedCall(10, kyowonAuthTimeout);										// if Kyowon service is broken, enable this to allow app to continue					//fakeKyowonAuth();									}else{					//create fake kyowon user info					CONFIG::DEBUG{ trace("[ StartupController ] "+"create fake Kyowon data"); }					fakeKyowonAuth();				}			}							CONFIG::NOTKYOWON {				checkSession();			}		}												/*********************************************************************		 * @category SPEAKABOOS NATIVE EXTENSION		 *********************************************************************/						private function initANE():void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"initANE"); }			if (SystemUtils.isAppleIOS()){				CONFIG::DEBUG{ trace("[ StartupController ] "+"Create ANEController - IOS implementation isn't working yet"); }			}else{				CONFIG::DEBUG{ trace("[ StartupController ] "+"Create ANEController"); }				_aneController = ANEController.getInstance();				_aneController.addEventListener(ANEController.KYOWON_AUTH_RESULT, onANEEvent);			}		}				public function onANEEvent(e:Event):void{						switch(e.type){				case ANEController.KYOWON_AUTH_RESULT:					CONFIG::DEBUG{ trace("[ StartupController ] "+"received Kyowon Authorization Result"); }					var kyowonUserObj:Object = ANEController.data.kyowonUser;					var kyowonUser:KyowonUser = new KyowonUser();										kyowonUser.userId = kyowonUserObj.userId;					kyowonUser.userCode = kyowonUserObj.userCode;					kyowonUser.expiredDate = kyowonUserObj.expiredDate;					kyowonUser.resultCode = kyowonUserObj.resultCode;										CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonUser.userId: "+kyowonUser.userId); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonUser.userCode: "+kyowonUser.userCode); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonUser.expiredDate: "+kyowonUser.expiredDate); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonUser.resultCode: "+kyowonUser.resultCode); }					//event.code in JSON format: {userId:userId, userCode:userCode, expiredDate:expiredDate, resultCode:resultCode}										if (kyowonUser.resultCode == "1"){												CONFIG::DEBUG{ trace("[ StartupController ] "+"**************************************"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"*** KYOWON USER AUTHORIZED by Kyowon Service"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"**************************************"); }						UserProfileImpl.getInstance().kyowonUser = kyowonUser;						checkSession();					}else{						CONFIG::DEBUG{ trace("[ StartupController ] "+"**************************************"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"*** KYOWON USER NOT AUTHORIZED by Kyowon Service"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"**************************************"); }											}										break;								default:			}		}						/*********************************************************************		 * @category ANDROID SPECIFIC		 *********************************************************************/				CONFIG::ANDROID {						//Handle Android System Events						private function handleActivate(event:Event):void{				NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;			}						private function handleDeactivate(event:Event):void{				CONFIG::DEBUG{ trace("[ StartupController ] "+"handleDeactivate"); }				appFinishAndroid();			}						private function handleKeys(event:KeyboardEvent):void{				CONFIG::DEBUG{ trace("[ StartupController ] "+"** handleKeys event.keyCode:"+event.keyCode); }				if(event.keyCode == Keyboard.BACK)					appFinishAndroid();			}						public static function appFinishAndroid():void{				//				NativeApplication.nativeApplication.exit();				ANEController.spkANE.appFinish();			}												private function onInvoke(event:InvokeEvent):void{				CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"onInvoke()"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }								var kyowonUser:KyowonUser = UserProfileImpl.getInstance().kyowonUser;				TweenLite.killDelayedCallsTo(kyowonAuthDeclined);								if (kyowonUser){					if (kyowonUser.resultCode == "1"){						CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"USER PREVIOUSLY AUTHENTICATED"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"     * Always show home screen - currently with: "); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"            * BookView.getInstance().resetBookAndGoHome();"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"     * Re-authenticate user/session"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"            * this is happening in the big if block below"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"     * Periodically check for updates"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }												BookView.getInstance().resetBookAndGoHome();											}else{						CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"USER PREVIOUSLY CREATED BUT NOT AUTHENTICATED"); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }											}				} else {					CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"USER NEVER CREATED - FIRST TIME LAUNCH OF APP"); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }				}								if(event.arguments.length > 0){										var uri:String = event.arguments[0];					var data:String = uri.split("://")[1];					var dataArray:Array = data.split("&");										CONFIG::DEBUG{ trace("[ StartupController ] "+"onInvoke(event) dataArray.length: "+dataArray.length); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"onInvoke(event) uri: "+uri); }										try{						var dataObj:Object = new Object();						for (var i:int=0; i<dataArray.length; i++){							var split:Array = dataArray[i].split("=");							CONFIG::DEBUG{ trace("[ StartupController ] "+"i: "+i+", split[0]: "+split[0]+", split[1]: "+split[1]); }														dataObj[split[0]] = split[1]; 						}												CONFIG::DEBUG{ trace("[ StartupController ] "+"dataObj.session: "+dataObj.session); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"dataObj.urlType: "+dataObj.urlType); }						CONFIG::DEBUG{ trace("[ StartupController ] "+"dataObj.companyCode: "+dataObj.companyCode); }												if (dataObj.session && dataObj.urlType && dataObj.companyCode){							CONFIG::DEBUG{ trace("[ StartupController ] "+"_ane.doKyowonAuth() :: START AUTHORIZATION VIA KYOWON JAR :: "); }							ANEController.spkANE.doKyowonAuth(dataObj.session, dataObj.urlType, dataObj.companyCode);						}else{							CONFIG::DEBUG{ trace("[ StartupController ] "+"ERROR - Params not valid for Kyowon Authorization"); }							kyowonAuthDeclined("ERROR - Params not valid for Kyowon Authorization");						}					}catch(e:Error){						CONFIG::DEBUG{ trace("[ StartupController ] "+"Error: "+e.type); }						kyowonAuthDeclined("Error: "+e.type);					}				} else {					kyowonAuthDeclined("event.arguments.length = 0");				}							}		}								/*********************************************************************		 * @category KYOWON SPECIFIC		 *********************************************************************/				CONFIG::KYOWON {						private function kyowonAuthTimeout():void{				CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonAuthTimeout()"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }								kyowonAuthDeclined();			}						private function kyowonAuthDeclined(msg:String = ""):void{								CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonAuthDeclined()"); }				CONFIG::DEBUG{ trace("[ StartupController ] "+"************************************************************"); }								if (_preloader) _preloader.pausePreload();				_appController.visible = true;				mc.parent.addChild(_appController);								CONFIG::DEBUG{ trace("[ StartupController ] "+"kyowonAuthDeclined() msg:"+msg); }								//ModalController exists, but AppController hasn't been added to stage yet, so regular modals can't be displayed yet				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.ERROR_KYOWON_AUTH_ID,  message:"Kyowon Auth Failed"}));							}									private function fakeKyowonAuth():void{				CONFIG::DEBUG{ trace("[ StartupController ] "+"fakeKyowonAuth"); }				var kyowonUserId:String = "kwUser" + MathUtils.getRandomInt(0,10);				var jsonData:String = '{"userId":"'+kyowonUserId+'","userCode":"userCode","expiredDate":"expiredDate","resultCode":"resultCode"}';				newKyowonUser(jsonData);			}									private function newKyowonUser(jsonString:String):void{				try{					jsonString = jsonString.split("'").join ("\"");					CONFIG::DEBUG{ trace("[ StartupController ] "+"newKyowonUser: "+jsonString); }										//REMOVE THIS WHEN WE GET CLEAN DATA FROM KYOWON SERVICE					//jsonString = '{"userId":"kwcsp06", "userCode":200, "expiredDate":null, "resultCode":1}';										var jsonObject:Object = JSON.parse(jsonString);										CONFIG::DEBUG{ trace("[ StartupController ] "+"jsonObject:"); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"jsonObject.userId: "+jsonObject.userId); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"jsonObject.userCode: "+jsonObject.userCode); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"jsonObject.expiredDate: "+jsonObject.expiredDate); }					CONFIG::DEBUG{ trace("[ StartupController ] "+"jsonObject.resultCode: "+jsonObject.resultCode); }										var kyowonUser:KyowonUser = new KyowonUser();					kyowonUser.userId = jsonObject.userId;					kyowonUser.userCode = jsonObject.userCode;					kyowonUser.expiredDate = jsonObject.expiredDate;					kyowonUser.resultCode = jsonObject.resultCode;										UserProfileImpl.getInstance().kyowonUser = kyowonUser;					checkSession();										CONFIG::DEBUG{ trace("[ StartupController ] "+"KyowonUser created"); }									}catch(e:Error){					CONFIG::DEBUG{ trace("[ StartupController ] "+"Error Parsing Kyowon Data Object: "+e.type); }					kyowonAuthDeclined();				}			}					}								/*********************************************************************		 * @category CHECK SESSION		 *********************************************************************/				private function checkSession():void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"checkSession()"); }						incrementTotal(SbProgressBar.CHECK_SESSION_PROG_INDEX, 1);						CoreEventDispatcher.getInstance().addEventListener(AppEvents.FINISH_INTRO, onCheckSession);			_appController.startUserFlow();			_appController.initAnx();		}				private function onCheckSession(e:GenericDataEvent=null):void{			CONFIG::DEBUG{ trace("[ StartupController ] "+"onCheckSession(e)"); }			incrementProgress(SbProgressBar.CHECK_SESSION_PROG_INDEX, 1);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.FINISH_INTRO, onCheckSession);			_preloader = new PreloadService();		}								/*********************************************************************		 * @category APP IN BACKGROUND		 *********************************************************************/						private function onAppInForeground(event:Event=null):void {			CentralEventDispatcher.getInstance().dispatchEvent(new StoryEvent(StoryEvent.RETURN_FROM_BACKGROUND));			if (!_preloader && AppController.instantiated) {				var curTime:Number = new Date().getTime();				CONFIG::DEBUG{ trace("[ StartupController ] "+"onAppInForeground(event)" + (_lastBackgroundTime < (curTime - MIN_IN_BACKGROUND_CHECK_TIME))+", "+(_lastBackgroundTime - (curTime - MIN_IN_BACKGROUND_CHECK_TIME))); }								if (_lastBackgroundTime < (curTime - MIN_IN_BACKGROUND_CHECK_TIME)) {					_resetPending = false;					_appController.firstOfflineModeChange = true;					var preloadDone:Boolean = introFinished || !_progBar || (_progBar.progress >= 1);					CONFIG::DEBUG{ trace("[ StartupController ] "+"onAppInForeground(event)"+_updateAvailable+","+_preloader+","+(PreloadService.lastUpdateTime - (curTime - MIN_UPDATE_CHECK_TIME))+", "+(!AppController.instantiated || _appController.appInteruptable())); }										if (preloadDone && (!AppController.instantiated || _appController.appInteruptable())) {						if (_updateAvailable && (PreloadService.lastUpdateTime < (curTime - MIN_UPDATE_CHECK_TIME))) {							_resetPending = true;						}						SpeakaboosService.getInstance().checkUdatedSince(onUpdateSinceLoaded);					}				}				_appController.checkOnline();			}		}										private function onAppInBackground(event:Event=null):void{						CONFIG::DEBUG {				CONFIG::DEBUG{ trace("[ StartupController ] "+"onAppInBackground(event)"); }				return;			}							CentralEventDispatcher.getInstance().dispatchEvent(new StoryEvent(StoryEvent.GO_TO_BACKGROUND));			_lastBackgroundTime = new Date().getTime();					}				private function onUpdateSinceLoaded(data:Object):void {			_updateAvailable = false;			if (data.status == "ok") {				_updateAvailable = ((int(data.categoriesUpdated) + int(data.storiesUpdated) + int(data.genericContentUpdated)) > 0);			}			if (_updateAvailable && _resetPending) _eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.FULL_RESET));						CONFIG::DEBUG{ trace("[ StartupController ] "+"onUpdateSinceLoaded(data) _updateAvailable, _resetPending = "+_updateAvailable+", "+_resetPending); }					}				/*********************************************************************		 * @category DESTROY		 *********************************************************************/						override public function destroy():void {			//TODO: finish destory			CONFIG::DEBUG{ trace("[ StartupController ] "+"destroy"); }			_updateAvailable = false;			_resetPending = false;			introFinished = false;			removeListeners();						if (AppController.instantiated) {				_appController.destroy();				mc.parent.removeChild(_appController);				_appController = null;			}						SpeakaboosService.destroySingleton();			SubscriptionService.destroySingleton();			LoginService.destroySingleton();			StoryDbService.destroySingleton();			UserProfileImpl.destroySingleton();			StoreKitService.destroySingleton();			NetworkMonitor.destroySingleton();			BookView.destroySingleton();			killIntroAnim();			if (_progBar) _progBar.destroy();			_progBar = null;			if (_preloader) _preloader.destroy();			_preloader = null;			CacheDataService.destroyStatic();			SocialUtils.destroy();						super.destroy();			CoreEventDispatcher.destroySingleton();			TweenMax.killAll();		}			}	}