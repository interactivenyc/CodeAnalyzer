package com.speakaboos.core.controller{	import com.speakaboos.core.anx.AnxController;	import com.speakaboos.core.anx.AnxDispatchQueue;	import com.speakaboos.core.events.AppEvents;	import com.speakaboos.core.events.CoreEventDispatcher;	import com.speakaboos.core.events.GenericDataEvent;	import com.speakaboos.core.events.ModalEvents;	import com.speakaboos.core.events.NavEvents;	import com.speakaboos.core.events.SpeakaboosServiceEvents;	import com.speakaboos.core.models.data.ModalsInfo;	import com.speakaboos.core.models.data.Story;	import com.speakaboos.core.models.data.UserProfile;	import com.speakaboos.core.models.impl.UserProfileImpl;	import com.speakaboos.core.models.services.CacheDataService;	import com.speakaboos.core.models.services.CoreService;	import com.speakaboos.core.models.services.LoginService;	import com.speakaboos.core.models.services.NetworkMonitor;	import com.speakaboos.core.models.services.SpeakaboosService;	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.core.utils.HtmlTextUtil;	import com.speakaboos.core.utils.MovieClipUtils;	import com.speakaboos.core.view.BookView;	import com.speakaboos.core.view.components.CoreMovieClip;	import com.speakaboos.core.view.holders.components.LogButton;	import com.speakaboos.mobile.data.db.connection.AsynchPoolController;	import com.speakaboos.mobile.ios.notifications.PushNotificationsController;	import com.speakaboos.story.controller.StoryController;	import com.speakaboos.story.events.CentralEventDispatcher;	import com.speakaboos.story.events.StoryEvent;	import com.speakaboos.story.utils.VideoPlayer;		import flash.debugger.enterDebugger;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TransformGestureEvent;	import flash.filesystem.File;	import flash.system.ApplicationDomain;	import flash.system.Capabilities;	import flash.system.ImageDecodingPolicy;	import flash.system.LoaderContext;	import flash.system.System;	import flash.ui.Multitouch;	import flash.ui.MultitouchInputMode;		import net.hires.debug.Stats;
		public class AppController extends CoreMovieClip	{		private static var _instance:AppController;		private static var initialized:Boolean = false;		//Services		private var _speakaboosService:SpeakaboosService;				//Main Views		private var _storyViewContainer:MovieClip;		private var _bookViewContainer:MovieClip;		private static var _storyController:StoryController;		private var _videoPlayer:VideoPlayer;				private var _loginViewContainer:MovieClip;		public var _loginController:LoginController;		private var _modalViewContainer:MovieClip;		public var modalController:ModalController; //Public so startupController can access if needed		private var _subscriptionController:SubscriptionController;		private var _pushNotificationsController:PushNotificationsController;		//		private var offlineMC:MovieClip;		private var modeBadgeMC:MovieClip;		public var bookGraphic:MovieClip;		public var logButton:LogButton;					private var _statsClip:Stats;				//State Variables		private static var _newSection:Boolean = true;		private static var _previousViewMode:String;		private static var _animating:Boolean = false;		private static var _firstOfflineModeChange:Boolean;				public static var firstTimeUser:Boolean;		public static var categoryPageInitialized:Boolean = false;		public static var inOfflineMode:Boolean;		private static var _inRestrictedMode:Boolean;		public static function get inRestrictedMode():Boolean {			return _inRestrictedMode && _okToShowTrialMode;		}				private static var _viewMode:String = MODE_CATEGORIES;				public static const MODE_CATEGORIES:String = "MODE_CATEGORIES";		public static const MODE_STORIES:String = "MODE_STORIES";		public static const MODE_STORY:String = "MODE_STORY";				public static var LOADER_CONTEXT:LoaderContext;		//THIS SHOULD BE KEPT BY SPEAKABOOSSERVICE		private var _inTrialMode:Boolean = false;		private var _appStateUpdatePending:Boolean;		private static var _okToShowTrialMode:Boolean;				//LET'S REPLACE CATEGORYBACK BY USING THE NEWLY CREATED PREVIOUSVIEWMODE		private static var _categoryBack:Boolean = false;										/*********************************************************************		 * GETTER/SETTERS		 *********************************************************************/				public function set firstOfflineModeChange(val:Boolean):void{_firstOfflineModeChange = val};				public static function set newSection(newSection:Boolean):void{_newSection = newSection};		public static function get newSection():Boolean{return _newSection};				public static function set categoryBack(categoryBack:Boolean):void{_categoryBack = categoryBack};		public static function get categoryBack():Boolean{return _categoryBack};				public static function get animating():Boolean{return _animating};		public static function set animating(animating:Boolean):void{_animating = animating};				public static function get previousViewMode():String{return _previousViewMode};				public static function get viewMode():String{return _viewMode};		public static function set viewMode(viewMode:String):void{			_previousViewMode = _viewMode;			_viewMode = viewMode;		}						/*********************************************************************		 * APP CONTROLLER CONSTRUCTOR		 *********************************************************************/						public function AppController(enforcer:SingletonEnforcer){			if( enforcer == null ) throw new Error( "AppController is a singleton class and should only be instantiated via its static getInstance() method" );		}				public static function get instantiated():Boolean {return Boolean(_instance)};		public static function getInstance():AppController {			if( _instance == null ) {				_instance = new AppController( new SingletonEnforcer() );			}			_instance.init();			return _instance;		}				override final static protected function init():void {			log("AppController init - called before (!initialized gets checked) "+initialized);						if (!initialized) {				initialized = true;				_appStateUpdatePending = false;				_firstOfflineModeChange = true;								Multitouch.inputMode = MultitouchInputMode.NONE;				LOADER_CONTEXT = new LoaderContext(false,ApplicationDomain.currentDomain,null); //avoids some security sandbox headaches that plague many users.								//SPECIFY ASYNCHRONOUS LOADING				LOADER_CONTEXT.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;								if (AppConfig.DEBUG_MODE) {					initLog();				}								_loginViewContainer = new MovieClip();				_bookViewContainer = new MovieClip();				_storyViewContainer = new MovieClip();				_modalViewContainer = new MovieClip();								_statsClip = new Stats(); //TODO: remove when removed from stage				_statsClip.y = 80;				if (!AppConfig.DEBUG_MODE) { 					addChild(_statsClip);				}				addChild(_loginViewContainer);				addChild(_bookViewContainer);				addChild(_storyViewContainer);				addChild(_modalViewContainer);								if (AppConfig.DEBUG_MODE) { 					addChild(_statsClip);				}				initControllers();				initServices();				_modalViewContainer.addChild(modalController.mc);			}		}				public function initBook():void {			visible = true;			checkOnline();			_okToShowTrialMode = true;			drawBackground();			_newSection = true;			addEventListeners();						modeBadgeMC = new RestrictedModeMC();			hideModeBadge();						MovieClipUtils.centerDisplayObject(modeBadgeMC);			modeBadgeMC.y = 0;										modeBadgeMC.addEventListener(MouseEvent.MOUSE_DOWN, onModeBadgeClicked);			addChild(modeBadgeMC);						_storyController = getStoryController();						_statsClip.x = Main.leftEdge;		}				public function startOpenBook():void {			checkOnline();			BookView.getInstance().showCategories();			appStateUpdated();		}				public function enterDebugger():void {			flash.debugger.enterDebugger();		}				override protected function onRemovedFromStage(e:Event):void{			super.onRemovedFromStage(e);			removeEventListeners();			resetViews();			_modalViewContainer.removeChild(modalController.mc);			if (_statsClip) removeChild(_statsClip);		}				private function initLog():void {			logButton = new LogButton(showLog);		}				private function addEventListeners():void{						stage.addEventListener(MouseEvent.MOUSE_DOWN, stageMouseDown);						//OTHER EVENTS			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_OPEN, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_CLOSED_ALL, receiveEvent);						CoreEventDispatcher.getInstance().addEventListener(NavEvents.GO_HOME, receiveEvent);						//APPLICATION EVENTS			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHECK_ONLINE_STATE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHECK_RESTRICTED_MODE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHANGE_VIEW_MODE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.NETWORK_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.APP_OFFLINE_MODE_CHANGE, onOfflineModeChange);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.PLAY_WELCOME_VIDEO, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.STORY_ASSETS_LOADED, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.NETWORK_STATUS, receiveEvent);						//SPEAKABOOS SERVICE EVENTS			CoreEventDispatcher.getInstance().addEventListener(SpeakaboosServiceEvents.LOAD_STORY, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(SpeakaboosServiceEvents.STORIES_LOADED, receiveEvent);						//GESTURE HANDLING - CENTRALIZED HERE			Multitouch.inputMode = MultitouchInputMode.GESTURE;			stage.addEventListener(TransformGestureEvent.GESTURE_SWIPE, onGestureEvent);					}				private function removeEventListeners():void{						stage.removeEventListener(MouseEvent.MOUSE_DOWN, stageMouseDown);						//OTHER EVENTS			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_OPEN, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_CLOSED_ALL, receiveEvent);						CoreEventDispatcher.getInstance().removeEventListener(NavEvents.GO_HOME, receiveEvent);						//APPLICATION EVENTS			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHECK_ONLINE_STATE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHECK_RESTRICTED_MODE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHANGE_VIEW_MODE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.NETWORK_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.APP_OFFLINE_MODE_CHANGE, onOfflineModeChange);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.PLAY_WELCOME_VIDEO, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.STORY_ASSETS_LOADED, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.NETWORK_STATUS, receiveEvent);						//SPEAKABOOS SERVICE EVENTS			CoreEventDispatcher.getInstance().removeEventListener(SpeakaboosServiceEvents.LOAD_STORY, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(SpeakaboosServiceEvents.STORIES_LOADED, receiveEvent);									//GESTURE HANDLING - CENTRALIZED HERE			Multitouch.inputMode = MultitouchInputMode.GESTURE;			if (stage) stage.removeEventListener(TransformGestureEvent.GESTURE_SWIPE, onGestureEvent);					}				private function stageMouseDown(e:MouseEvent):void{			if (inOfflineMode == true) checkOnline();		}								private function initServices():void{			log("*** initServices");			_speakaboosService = SpeakaboosService.getInstance();		}				public function startUserFlow():void{			log("*** startUserFlow()");			//DB creation and init handled in StartupController			CONFIG::KYOWON{				_loginController.initKyoWonAuth(getKyoWonUser());			}							CONFIG::NOTKYOWON{				UserProfileImpl.getInstance().getLastKnownUser(onGetLastUserProfile);			}				}				final public function initAnx():void{			AnxController.getInstance(); //.runSamples();		}						private function initControllers():void {			log("*** initControllers()");			UserProfileImpl.getInstance();			modalController = new ModalController(this);			_subscriptionController = new SubscriptionController(this);						_pushNotificationsController = new PushNotificationsController();			if(!_pushNotificationsController.init()){				_pushNotificationsController.destroy();				_pushNotificationsController = null;						}			initLoginView();		}				private function initLoginView():void{			log("initLoginView");			resetLoginView();		}						/**		 * This function gets called by DBService, after it has opened the local		 * database, and retrieved the stored userProfile		 **/ 				private function onGetLastUserProfile(u:UserProfile):void{				//log("*** onGetLastUserProfile");			//log(ObjectUtils.getGenericObject(u));						if(u == null){				//log("user not found in db");				firstTimeUser = true;				_loginController.createNewAnonSession();							}else{				LoginService.getInstance().setUserProfile(u);				if (inOfflineMode) { //TODO: something better when in offline mode					_subscriptionController.doSubscriptionFlow();				} else {					//log("checking session");					//LoginService.getInstance().checkSession(u);					_loginController.checkSession();				}			}		}						private function showLog(e:Event = null):void{			//log("showLog");			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_LOG));			}						public static function appendLog(m:String):void {			ModalController.logMessage(m);		}				/*********************************************************************		 * PAGE DISPLAY		 *********************************************************************/				private function resetViews():void{			//log("resetViews");			//BookView.getInstance().removeCurrentView();			if(this.contains(_bookViewContainer)){				_bookViewContainer.removeChild(BookView.getInstance().mc);			}			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));			//_globalNav.reset();			resetLoginView();		}				private function resetLoginView():void{			appStateUpdated();						if(_loginController){				log("resetting loginView");				if (_loginViewContainer.contains(_loginController)) {					_loginViewContainer.removeChild(_loginController);				}				var lvc:LoginController = _loginController as LoginController;				lvc.destroy();				lvc = null;				_loginController = null;			}						log("instantiating login view");			_loginController = new LoginController(this);			_loginViewContainer.addChild(_loginController);					}				private function drawBackground():void{			//log("drawBackground");						_bookViewContainer.addChild(BookView.getInstance().mc);						if (AppConfig.DEBUG_MODE == true){				if (!_modalViewContainer.contains(logButton.mc)) {					logButton.mc.x = Main.leftEdge + 15;					logButton.mc.y = 15;					addChild(logButton.mc);				}			}		}				private function showNetworkErrorDialog():void{			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.NETWORK_ERROR_ID }));		}						/*********************************************************************		 * ONLINE AND RESTRICTED MODES		 *********************************************************************/						public function checkOnline(e:Event = null):Boolean {			log("* checkOnline NetworkMonitor.getInstance().isOnline: "+NetworkMonitor.getInstance().isOnline);						if (NetworkMonitor.getInstance().isOnline) {				if (inOfflineMode) updateOfflineMode(false);				return true;			} else {				if (!inOfflineMode) {					updateOfflineMode(true);				}				return false;			}		}				private function onOfflineModeChange(e:GenericDataEvent):void {			log("onOfflineModeChange offline: "+e.data.offline);						updateOfflineMode(e.data.offline);		}				private function updateOfflineMode(pOffline:Boolean):void {			//log("updateOfflineMode offline: "+pOffline+", "+inOfflineMode+", "+_firstOfflineModeChange);			if (CacheDataService.preloadComplete) { // && (inOfflineMode != pOffline)) { 				var offlineChanged:Boolean = inOfflineMode !== pOffline;				if (pOffline && _firstOfflineModeChange) {					if (viewMode === MODE_STORY) {						return;					}					_firstOfflineModeChange = false;					offlineChanged = true;					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id: ModalsInfo.NEED_CONNECTION_ID}));				}				inOfflineMode = pOffline;				if (offlineChanged) {					appStateUpdated();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.CONNECTION_MODE_CHANGED));				}				log("* updateOfflineMode inOfflineMode: "+inOfflineMode);			}		}				public function updateRestrictedMode(restricted:Boolean, freeTrialer:Boolean = false):void {			//			log("* updateRestrictedMcVis restricted: "+restricted+", trialer:"+freeTrialer+", offline:"+inOfflineMode);			var updated:Boolean = false;			if (freeTrialer !== _inTrialMode) {				_inTrialMode = freeTrialer;				updated = true;			}			if (_inRestrictedMode !== restricted) {				_inRestrictedMode = restricted;				updated = true;			}			if (updated) {				appStateUpdated();				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.RESTRICTED_MODE_CHANGED, {restricted:restricted, freeTrialer:_inTrialMode}));			}		}		private function updateModeBadge():void {			log("updateModeBadge");			SpeakaboosService.getInstance().storyLimitReached();						var txt:String;			//Set badge text based on sub expired or not			if (inOfflineMode) {				txt = "<p>You're Not<br>Connected</p>";			} else {				if (UserProfileImpl.getInstance().subscriptionHasExpired()) {					txt = "<p>Your Subscription<br>Has Expired</p>";				} else {					if (inRestrictedMode) {						txt = "<p>Keep Reading,<br>Join Today!</p>"					} else {						txt = "<p>Try Three<br>Stories Free!</p>"					}				}			}			HtmlTextUtil.setFieldText(modeBadgeMC.label, txt, HtmlTextUtil.BUTTON);						CONFIG::KYOWON {				modeBadgeMC.visible = inOfflineMode && (_viewMode !== MODE_STORY);			}							CONFIG::NOTKYOWON {				modeBadgeMC.visible = (_inRestrictedMode || _inTrialMode || inOfflineMode) && (_viewMode !== MODE_STORY);			}					}				private function hideModeBadge():void{			log("hideModeBadge");			modeBadgeMC.visible = false;		}				private function onModeBadgeClicked(e:MouseEvent):void {			if (inOfflineMode) {				checkOnline();			} else if (_inRestrictedMode) {				_okToShowTrialMode = true;				_loginController.showSubscribe();			}		}										/*********************************************************************		 * EVENT HANDLING		 *********************************************************************/						private function onGestureEvent(e:TransformGestureEvent):void{			//log("onGestureEvent: target: "+e.target+", stageLoc: ("+e.stageX+","+e.stageY + ") localLoc: ("+e.localX+","+e.localY+")");			//log("ModalController.modalOpen(): "+ModalController.modalOpen());						if (appInteruptable()) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.ON_GESTURE, {gestureEvent:e}));			}		}				public function appInteruptable(ignoreAnimating:Boolean = false):Boolean {			return (ignoreAnimating || !_animating) && (_viewMode !== MODE_STORY) && modalController && !(modalController.modalOpen());		}				private function receiveEvent(e:GenericDataEvent):void{			log("* receiveEvent type:"+e.type);						var i:int;						switch(e.type){								case AppEvents.NETWORK_ERROR:					if (StartupController.introFinished) {						if (NetworkMonitor.getInstance().isOnline) {							showNetworkErrorDialog();						} else {							updateOfflineMode(true);						}					} else {						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));					}					break;								//SPEAKABOOS SERVICE EVENTS						case SpeakaboosServiceEvents.STORIES_LOADED:					if (_speakaboosService.categoryHasSavedStories() || checkOnline()) {						_newSection = true;						BookView.getInstance().showStories();					}					break;								case SpeakaboosServiceEvents.LOAD_STORY:					var story:Story = SpeakaboosService.getInstance().story;					log("load story saved?", story.saved, story.slug);					var fullAccess:Boolean = !SpeakaboosService.getInstance().storyLimitReached();					//	var fullAccess:Boolean = (_speakaboosService.savedStoryCount < storySaveLimit);					if (story.saved || (checkOnline() && fullAccess)) {						_newSection = true						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));						BookView.getInstance().showStory();						hideModeBadge();					} else if (!fullAccess) {						_okToShowTrialMode = true;						if (viewMode === MODE_STORY) CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.SHOW_HOME_SCREEN));						_loginController.showSubscribe();					}					break;								case AppEvents.MODAL_OPEN:						hideModeBadge();					break;				case AppEvents.MODAL_CLOSED_ALL:					appStateUpdated(); //TODO: Should not need this, but sometimes mode changes are not completed, or calls left hanging					break;											case NavEvents.GO_HOME:					if (AppConfig.DEBUG_MODE) flash.system.System.gc(); 					break;				case AppEvents.CHANGE_VIEW_MODE:					log("*** Event: CHANGE_VIEW_MODE: "+e.data.viewMode);										if (_viewMode == MODE_STORY) {						if (e.data.viewMode == MODE_CATEGORIES){							// going from a story straight back to the homepage							BookView.getInstance().suppressPageFlips = true;						}					}					viewMode = e.data.viewMode;					if (_appStateUpdatePending) {						appStateUpdated();					} else {						updateModeBadge();					}					break;				case AppEvents.PLAY_WELCOME_VIDEO:					playWelcomeVideo();					break;				case AppEvents.CHECK_ONLINE_STATE:					checkOnline();					break;				case AppEvents.CHECK_RESTRICTED_MODE:					updateModeBadge();					break;				case AppEvents.STORY_ASSETS_LOADED:					SpeakaboosService.getInstance().storyLimitReached(); //TODO: check if this is necessary, I think SpeakaboosService will have already checked this when assets load					break;			}		}				/*********************************************************************		 * WELCOME VIDEO		 *********************************************************************/		private function prepVideo():void {			if (!_videoPlayer || !contains(_videoPlayer)) {				_videoPlayer = VideoPlayer.getInstance();				_videoPlayer.addToStage(stage);			}		}				public function playWelcomeVideo(e:Event = null):void{			log("* PLAY_WELCOME_VIDEO");			//var file:File = FileUtil.getAppBundleSubPath("/data/video/welcome-video.mp4");						var file:File = File.applicationDirectory.resolvePath("data/video/welcome-video.mp4");			if(!file.exists){				log("File does not exist.  calling endWelcomeVideo");				endWelcomeVideo();			}else{				log("File exists.  starting video playback ", stage);				log(file.url);				//TODO: Fix this hack				//hack to fix intro video crash				getStoryController();				prepVideo();				CentralEventDispatcher.getInstance().addEventListener(StoryEvent.VIDEO_ENDED, endWelcomeVideo);				_videoPlayer.playVideo(file.url);				log("video playback started _videoPlayer.stage:", _videoPlayer.stage);			}					}				private function endWelcomeVideo(e:StoryEvent=null):void{			CONFIG::DEBUG {				trace("[ AppController ] endWelcomeVideo(e)");			}			var ced:CentralEventDispatcher = CentralEventDispatcher.getInstance();			if(ced.hasEventListener(StoryEvent.VIDEO_ENDED)){				ced.removeEventListener(StoryEvent.VIDEO_ENDED, endWelcomeVideo);			}						if (_videoPlayer) _videoPlayer.removeFromStage();		}				/*********************************************************************		 * USER AND SUBSCRIPTION METHODS		 *********************************************************************/					/* accessors */		public function getUserProfileImpl():UserProfileImpl{			return UserProfileImpl.getInstance();		}				public function getSubscriptionController():SubscriptionController{			return _subscriptionController;		}				public function getUserID():String{			return getUserProfileImpl().userProfile.user_id;		}				public function getKyoWonUser():String{			var kyUserName:String = UserProfileImpl.getInstance().kyowonUser.userId;						log("getKyoWonUser: "+kyUserName);						return kyUserName;		}						public function appStateUpdated():void {			if (StartupController.introFinished) { 				if (_viewMode == MODE_STORY) { //don't bother updating state when in MODE_STORY - but update next time out of story mode					_appStateUpdatePending = true;				} else {					_appStateUpdatePending = false;					HtmlTextUtil.textSubstitutions = textSubstitutionObj;					var u:UserProfile = LoginService.getInstance().getUserProfile();					if (u && (u.subscription_state === UserProfileImpl.SUB_STATE_ACTIVE)) {						//if(){						//FREE_STORY_LIMIT = int.MAX_VALUE;					} else {						//storySaveLimit = FREE_STORY_LIMIT;					}					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.USER_DATA_UPDATED));				}				updateModeBadge();			}		}				/* removed "getTextSubstitutions" to avoid confusion		This just sets up a object map for the properties to be replaced in text, using the same values as were in getTextSubstitutions		HtmlTextUtil uses this mapping to do the actual substitutions, this allows on the fly replacing and updating 		of map elements, setting the story name in the map before the dialog is shown for deleting a story.		*/		public function get textSubstitutionObj():Object {//			log("get textSubstitutionObj()");						var result:Object = {				"version_num": AppConfig.APP_VERSION,					"cr_year": AppConfig.copyrightYear,					"subscriberType": "iPad"			};		CONFIG::DEBUG {			result["air_version"] = AppConfig.airVersion;			result["app_id"] = AppConfig.appId;		}								var usrPrf:UserProfile = LoginService.getInstance().getUserProfile();			var strEmpty:String = "";			var str:String;//			log("got email address from profile: " + usrPrf.email);			str = (usrPrf) ? usrPrf.email : strEmpty;//'noProfile@example.com';			str = (str == null) ? strEmpty : str;//'noEmail@example.com' : strEmail; //			log("email str: '" + str + "'" + ", sub state: " + usrPrf.subscription_state);			if (str == "" && UserProfileImpl.getInstance().isSubscriber()){//				log("setting email to 'iPad Subscriber' for display purposes");				str = "iPad Subscriber";			}			result["email"] = str;						str = (usrPrf) ? usrPrf.subscription_type : strEmpty;//':userProfile N/A:';			str = (str == null) ? strEmpty : str;//':subscriber type N/A:' : strSubType;			str = (str == 'itunes') ? "iPad" : str;			result["subscriber_type"] = str;						result["subscription_time"] = "";//usrPrf.getDaysLeft();//"30 days"; //TODO:  replace with real data						result["renew_date"] = usrPrf.getExpirationDate();						result["spe_version"] = StoryController.VERSION;			result["app_services"] = CoreService.baseURL;			CONFIG::RELEASE_DEV {				result["app_release_type"] = "dev";			}			CONFIG::RELEASE_ADHOC {				result["app_release_type"] = "adhoc";			}			CONFIG::RELEASE_APP_STORE {				result["app_release_type"] = "app_store";			}			result["screen_ppi"] = Capabilities.screenDPI;						return result;		}				public function getStoryController():StoryController {			if (!_storyController) {				_storyController = new StoryController(Main.deviceWidth, Main.deviceHeight, AppConfig.DEBUG_MODE);				log("instantiating StoryController at: "+Main.visibleWidth+" x "+Main.STAGE_HEIGHT);			} else {				log("NOT instantiating StoryController");			}			if (!_storyViewContainer.contains(_storyController)) {				_storyViewContainer.addChild(_storyController);			}			return _storyController;		}				public function releaseStoryController():void {			if (_storyController) {				_storyViewContainer.removeChildren();				_storyController.reset();			}		}				override public function destroy():void {			log("destroy");			reset();			_instance = null;		}				public function reset():void {			log("AppController reset");						AnxDispatchQueue.destroySingleton();			AnxController.destroySingleton();			_firstOfflineModeChange = false;			categoryPageInitialized = false;			_viewMode = MODE_CATEGORIES;			_previousViewMode = null;			_newSection = true;			_animating = false;			//storySaveLimit = FREE_STORY_LIMIT;			inOfflineMode = false;			_okToShowTrialMode = false;			_inRestrictedMode = false;						removeEventListeners();			firstTimeUser = true;			_statsClip = null;			if (logButton && _modalViewContainer.contains(logButton.mc)) {				_modalViewContainer.removeChild(logButton.mc);				logButton.destroy();			}			logButton = null;			releaseStoryController();			if (modalController) modalController.destroy();			if (_subscriptionController) _subscriptionController.destroy();			if (_pushNotificationsController) _pushNotificationsController.destroy();			modalController = null			_subscriptionController = null;			_pushNotificationsController = null;			_speakaboosService = null;			AsynchPoolController.destroySingleton();			super.destroy();			removeChildren();			initialized = false;		}	}}class SingletonEnforcer {	public function SingletonEnforcer():void {}}