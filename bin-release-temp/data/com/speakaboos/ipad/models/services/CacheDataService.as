package com.speakaboos.ipad.models.services{	import com.speakaboos.ipad.controller.AppController;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.events.ModalEvents;	import com.speakaboos.ipad.utils.FileUtil;	import com.speakaboos.story.controller.StoryController;		import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.filesystem.File;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;	/*		Purpose: To retrieve non-media data and potentially cache	*/			public class CacheDataService extends CoreService	{		public static const DEFAULT_DATA_FORMAT:String = "json";		public static const UPDATED_SINCE_METHOD:String = "updatedSince";		public static const GET_CATEGORIES_METHOD:String = "getCategories";		public static const GET_STORIES_BY_CATEGORY_METHOD:String = "getStoriesByCategory";		public static const GENERIC_DATA_METHOD:String = "getgenericcontent";		public static const TERMS_OF_USE_SLUG:String = "terms-of-use";		public static const PRIVACY_POLICY_SLUG:String = "privacy-policy";		public static const MANAGE_YOUR_ACCOUNT_SLUG:String = "manage-your-account";		public static const HELP_FAQS_SLUG:String = "help-faqs";		public static const CSS_STYLESHEET_SLUG:String = "css-stylesheet";		public static const SPEAKABOOS_STORY_SLUG:String = "the-speakaboos-story";		public static const CAST_SLUG:String = "cast-of-characters";		public static const SLUG_SUBTYPE:String = "slug";		public static const CATEGORY_SUBTYPE:String = "category";		protected var _curCallback:Function; //also serves as a flag to determine if in middle of call		protected var _curDataKey:String;		protected var _curParams:URLVariables;		protected var runningLocal:Boolean = false;		private var _cacheCurLoad:Boolean = true;		private var _cacheDir:File;		private static var _dataCache:Object;		private static var _classInitted:Boolean = false;		protected static var _preloadComplete:Boolean = false;		protected static var _upToDate:Object;				public static function get preloadComplete():Boolean {			return _preloadComplete;		}				public function CacheDataService() {			super();		}				public static function classInit():void {			_classInitted = true;			_dataCache = {};			_upToDate = {};			_preloadComplete = false;		}				protected function addToDataCache(data:Object):void {//			log("addToDataCache ("+chachedProps.length+")"+chachedProps.join(","));			if (data) {				for (var prop:String in data) {					_dataCache[prop] = data[prop];					if (prop==="updatedSince.json") {						log(prop,data[prop]);					}				}			}//			log("addToDataCache after add ("+chachedProps.length+")"+chachedProps.join(","));		}		protected function get chachedProps():Array {			var results:Array = [];			for (var prop:String in _dataCache) results.push(prop);			return results;		}				protected function get dataCache():Object {			return _dataCache;		}				protected function init():void {			if (!_classInitted) {				classInit();				_eventDispatcher.addEventListener(AppEvents.NETWORK_STATUS, onNetworkStatusUpdate);			}			urlRequest = new URLRequest(getBaseURL());			urlRequest.method = URLRequestMethod.POST;//			_dataCache = ServiceCacheData.data;//			log("init(this is PreoadService)"+(this is PreoadService));//			if (!(this is PreoadService)) {//				_preoader = new PreoadService();//			}			// check for saved data file:			_cacheDir = FileUtil.getCacheDir();					}						protected function onNetworkStatusUpdate(event:GenericDataEvent):void {			if (_curCallback && event.data.isOnline) {				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_MESSAGE_MODALS));				doCurLoad();			}		}				protected function getPreloadedData(method:String, subtype:String = "", dataFormat:String = DEFAULT_DATA_FORMAT):Object {			_curDataKey = method+ (subtype ? ("-"+subtype) : "") +"." + dataFormat;			return _dataCache[_curDataKey];		}				public function checkUdatedSince(completeCallback:Function):void {			getData(completeCallback, UPDATED_SINCE_METHOD);		}				protected function getData(completeCallback:Function, method:String, cache:Boolean = true, subtype:String = "", subtypeName:String = "", dataFormat:String = DEFAULT_DATA_FORMAT):void{			_curDataKey = method+ (subtype ? ("-"+subtype) : "") +"." + dataFormat;			_cacheCurLoad = cache; //not currently ever set to false			var data:Object = _dataCache[_curDataKey];			log("getData "+_preloadComplete+", "+_curDataKey+", "+_upToDate[method]+", "+_cacheCurLoad);			if (( _preloadComplete || _upToDate[method] || AppController.inOfflineMode) && ((method !== UPDATED_SINCE_METHOD) || AppController.inOfflineMode) && data) {				completeCallback(data); 			} else {				_curParams = new URLVariables();								if (data) {					_curParams.timestamp = data.timestamp;				}else {					_curParams.timestamp = 0;				}								log("getData loaded from webload:"+_curDataKey+", _curParams.timestamp:"+_curParams.timestamp+", data.timestamp: "+(data && data.timestamp));								_curCallback = completeCallback;				_curParams.method = method;				_curParams.format = dataFormat;				_curParams[subtypeName] = subtype;				var v:String = StoryController.VERSION;				if (v) {					v = v.split(" ")[0];					if (v && (method === GET_STORIES_BY_CATEGORY_METHOD || method === GET_CATEGORIES_METHOD)) {						_curParams.speVersion = v;					}				}				//adding cache-buster param in case device is implementing a local cache...//				_curParams.cb = String(new Date().getTime());				doCurLoad();			}		}				protected function doCurLoad():void {			if (runningLocal){				urlRequest.url = "data/v2/"+_curDataKey;			}else{				urlRequest.data = _curParams;			}			loader.addEventListener(Event.COMPLETE, onDataLoaded);			loader.load(urlRequest);		}				protected function onDataLoaded(event:Event):void		{//			log("******************************************");//			log("*** ononDataLoaded");//			log("******************************************");						loader.removeEventListener(Event.COMPLETE, onDataLoaded);			if (_preloadComplete && _cacheCurLoad && (_curParams.method !== UPDATED_SINCE_METHOD)) {				log("onDataLoaded called after preload - nothing done");				// do nothing, this must be left over from a call when the application when offline.			} else {								var decoder:Object = JSON.parse(loader.data);				loader.data = null;								if (decoder.response.status == "ok") {					var callback:Function = _curCallback;					_curCallback = null;					if (_cacheCurLoad) {						//log("decoder.response.timestamp: "+_curParams.timestamp+", "+decoder.response.timestamp+", "+!decoder.response.timestamp +", "+ (Number(_curParams.timestamp) < Number(decoder.response.timestamp)));						var cacheTimestamp:Number = Number(_curParams.timestamp);						var responseTimestamp:Number = Number(decoder.response.timestamp);						if (isNaN(responseTimestamp) || !responseTimestamp || (cacheTimestamp < responseTimestamp) 							|| (_curDataKey.split(".")[0] === UPDATED_SINCE_METHOD)) { //if timestamp we have is older, or it is the updateSince call then use the new data							_dataCache[_curDataKey] = decoder.response;							//log("onDataLoaded newer from web "+_curParams.toString());						}						callback(_dataCache[_curDataKey]); 					} else {						callback(decoder.response);					}				} else {					log("ERROR: "+decoder.response.error);				}			}		}				override protected function onIOError(e:IOErrorEvent):void{			loader.removeEventListener(Event.COMPLETE, onDataLoaded);			log("onIOError: "+e.text);			_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.NETWORK_ERROR, {error:e}));			if (_dataCache[_curDataKey]) _curCallback(_dataCache[_curDataKey]);		}				override protected function onSecurityError(e:SecurityError):void{			loader.removeEventListener(Event.COMPLETE, onDataLoaded);			log("service SecurityError: "+e.message);			_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.NETWORK_ERROR, {error:e}));		}				override public function destroy():void {			//TODO: flesh this out			loader.removeEventListener(Event.COMPLETE, onDataLoaded);			loader = null;			_eventDispatcher.removeEventListener(AppEvents.NETWORK_STATUS, onNetworkStatusUpdate);			super.destroy();		}				public static function destoryStatic():void {
			_classInitted = false;			_preloadComplete = false;			_upToDate = null;			_dataCache = null;		}	}}