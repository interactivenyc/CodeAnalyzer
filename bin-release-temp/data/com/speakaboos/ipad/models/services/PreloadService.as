package com.speakaboos.ipad.models.services{	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.core.utils.SystemUtils;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.view.components.CacheLoader;	import com.speakaboos.ipad.controller.StartupController;	import com.speakaboos.ipad.view.holders.components.SbProgressBar;		import flash.events.ErrorEvent;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.utils.ByteArray;			public class PreloadService extends CacheDataService	{		public static var lastUpdateTime:Number = 0;		private static const DATA_FILENAME:String = CacheLoader.DATA_FOLDER + "/datacache.bin";		private var _genSlugs:Array = [CSS_STYLESHEET_SLUG, CAST_SLUG, SPEAKABOOS_STORY_SLUG, HELP_FAQS_SLUG, MANAGE_YOUR_ACCOUNT_SLUG, PRIVACY_POLICY_SLUG, TERMS_OF_USE_SLUG];		private var _catSlugs:Array;		private var _getDataParams:Array;		private var _curMethod:String;		private var _cacheLoader:CacheLoader;		private var _dataByteArray:ByteArray;		//TODO: deal with checking for updated data				public function PreloadService()		{			super();			init();		}				override protected function init():void		{			var dba:ByteArray;			super.init();			if (!lastUpdateTime) lastUpdateTime = new Date().getTime(); // since this is static, it will persist			log("begin preloader");			CacheDataService.classInit();			_catSlugs = [];			_cacheLoader = new CacheLoader();			var cacheData:Object;			_dataByteArray = _cacheLoader.loadFromCache(DATA_FILENAME, 2);			if (_dataByteArray) {				log("cache dir data exists");				cacheData = _dataByteArray.readObject();//				if (!cacheData.appVersion || SystemUtils.compareVersionStrings(cacheData.appVersion, AppConfig.APP_VERSION) < 0) {				if (cacheData.appVersion && SystemUtils.compareVersionStrings(cacheData.appVersion, AppConfig.APP_VERSION) < 0) {					// if the app storage is from an earlier version (but has versioning), then use the bundle, and set firstTimeLaunched					dba = _cacheLoader.loadFromCache(DATA_FILENAME, 1);					if (dba) {						log("bundle dir data exists");						_dataByteArray = dba;						cacheData = _dataByteArray.readObject();						CacheLoader.firstTimeLaunched = true;					}				}			} else {				dba = _cacheLoader.loadFromCache(DATA_FILENAME, 1);				if (dba) {					log("bundle dir data exists");					_dataByteArray = _cacheLoader.loadFromCache(DATA_FILENAME, 1);					cacheData = _dataByteArray.readObject();					CacheLoader.firstTimeLaunched = true;				}			}			log("firstTimeLoaded: "+CacheLoader.firstTimeLaunched);			if (cacheData) {				addToDataCache(cacheData);			} else {				_dataByteArray = new ByteArray();			}			addListeners();			log("firstTimeLaunched "+CacheLoader.firstTimeLaunched);			StartupController.incrementTotal(SbProgressBar.CHECK_UPDATE_INDEX, 1);//			if (CacheLoader.firstTimeLaunched) { //TODO: always check for updates, even on first time//				_getDataParams = []; //don't preload if first time launching//			} else {				_getDataParams = [[onLoadData, UPDATED_SINCE_METHOD]];//			}			//			_getDataParams = [[onLoadData, GET_CATEGORIES_METHOD]];			nextPreload();					}				private function onLoadMedia(e:GenericDataEvent):void {						StartupController.incrementProgress(SbProgressBar.GET_MEDIA_PROG_INDEX, 1);			nextPreload();		}				private function onLoadData(data:Object):void {			log("onLoadData", data.status, _curMethod);			var i:int, j:int, n:int;			if (data.status == "ok") {				switch (_curMethod) {					case UPDATED_SINCE_METHOD:						StartupController.incrementProgress(SbProgressBar.CHECK_UPDATE_INDEX, 1);						_upToDate[GET_CATEGORIES_METHOD] = (int(data.categoriesUpdated) != 1);						_upToDate[GET_STORIES_BY_CATEGORY_METHOD] = (int(data.storiesUpdated) != 1);						_upToDate[GENERIC_DATA_METHOD] = (int(data.genericContentUpdated) != 1);						StartupController.incrementTotal(SbProgressBar.GET_CATS_PROG_INDEX, 1);//						log("_upToDate",_upToDate);//						log("datg",data);						_getDataParams.push([onLoadData, GET_CATEGORIES_METHOD]); // should be length zero at this point, test for that?						break;					case GET_CATEGORIES_METHOD://we have just loaded the categories, and need to build the rest of the data calls from that						StartupController.incrementProgress(SbProgressBar.GET_CATS_PROG_INDEX, 1);						StartupController.incrementTotal(SbProgressBar.GET_MEDIA_PROG_INDEX, 1);						StartupController.incrementTotal(SbProgressBar.GET_STORIES_PROG_INDEX, 1);						var items:Array = [];						n = 0;						if (!_upToDate[GET_STORIES_BY_CATEGORY_METHOD]) {							items = data.categories.on_book.concat(data.categories.in_wheel);							log("updating stories items.length: " + items.length);							for (i = 0; i<items.length; i++) {								_getDataParams.push([onLoadData, GET_STORIES_BY_CATEGORY_METHOD, true, items[i].slug, CATEGORY_SUBTYPE]);								n += addMediaProps(_getDataParams, items[i]);							}							StartupController.incrementTotal(SbProgressBar.GET_STORIES_PROG_INDEX, items.length);							StartupController.incrementTotal(SbProgressBar.GET_MEDIA_PROG_INDEX, n);						}						StartupController.incrementProgress(SbProgressBar.GET_STORIES_PROG_INDEX, 1);						for (var prop:String in data.categories) {							items = data.categories[prop];							if (!_upToDate[GET_CATEGORIES_METHOD]) {								if (items) {									n = 0;									for (i = 0; i<items.length; i++) {										n += addMediaProps(_getDataParams, items[i]);									}									StartupController.incrementTotal(SbProgressBar.GET_MEDIA_PROG_INDEX, n);								}							}						}						StartupController.incrementTotal(SbProgressBar.GET_DATA_PROG_INDEX, 1);						if (!_upToDate[GENERIC_DATA_METHOD]) {							for (i=0; i<_genSlugs.length; i++) {								_getDataParams.push([onLoadData, GENERIC_DATA_METHOD, true, _genSlugs[i], SLUG_SUBTYPE]);							}							StartupController.incrementTotal(SbProgressBar.GET_DATA_PROG_INDEX, _genSlugs.length);						}						StartupController.incrementProgress(SbProgressBar.GET_DATA_PROG_INDEX, 1);						//log("onLoadData "+_getDataParams.length);						//log(_getDataParams);						break;					case GET_STORIES_BY_CATEGORY_METHOD:						StartupController.incrementProgress(SbProgressBar.GET_STORIES_PROG_INDEX, 1);						var stories:Array = data.stories;						n = 0;						for (i = 0; i<stories.length; i++) {							n += addMediaProps(_getDataParams, stories[i]);						}						StartupController.incrementTotal(SbProgressBar.GET_MEDIA_PROG_INDEX, n);						break;					default:						StartupController.incrementProgress(SbProgressBar.GET_DATA_PROG_INDEX, 1);				}									} else {				log("ERROR: "+data["error"]);				log(data);			}			nextPreload();		}				private function addMediaProps(list:Array, obj:Object):int {			var result:int = 0;			var prop:String;			var val:String;			for (prop in obj) {				val = obj[prop];				//				if ((val.indexOf("http") == 0) && (val.indexOf("/200x150/")<0)) { //TODO: remove this exclusion when fate of thumbnails is decided				if (val && (val.indexOf("http") == 0)) { //TODO: remove this exclusion when fate of thumbnails is decided					if (!_cacheLoader.isMediaLocal(val)) {						_getDataParams.push([onLoadMedia, val]);						result++;					}				}			}			return result;		}				protected function onLoadMediaError(e:GenericDataEvent):void		{			log("****** "+e.data.error);			checkNetworkForNext()		}				protected function onLoadError(e:ErrorEvent):void		{			log("****** "+e.errorID);			checkNetworkForNext()		}				protected function checkNetworkForNext():void		{			if (NetworkMonitor.getInstance().isOnline) {				nextPreload(); //If we get an error in preload, just skip the file...			} else {				removeListeners();				_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.APP_OFFLINE_MODE_CHANGE, {offline:true}));				_getDataParams.length = 0;				nextPreload(); // end preload			}		}				protected function nextPreload():void		{			log("nextPreload "+_getDataParams.length);			if (!_preloadComplete) {				//			log("nextPreload len="+_getDataParams.length);				if (_getDataParams.length) {					var params:Array = _getDataParams.shift();					_curMethod = params[1];					if (params[0] === onLoadData) {						//					log("nextPreload onLoadData "+params);						getData.apply(this, params);					} else { //load and save media to local cache						//					log("nextPreload preloadMedia "+params);						_cacheLoader.preloadMedia(params[1]);					}				} else { // wer're done					//TODO: process data here maybe add a progress category for this. E.g., create category icons for the home screens from the swfs be loading them, setting last frame and drawing into a bitmap					//  this might be something to throw away and redo when going and coming back from a story to reduced memory footprint										// at this point all the load progress should be done//					_eventDispatcher.dispatchEvent(new GenericDataEvent( PreloadService.PROGRESS_UPDATED, {progress:1}));					_dataByteArray.clear();										//*******************************************************					//revert revision ab0eaf6 - commented out this line					//*******************************************************					dataCache.appVersion = AppConfig.APP_VERSION;										_dataByteArray.writeObject(dataCache);					_cacheLoader.saveToCache(DATA_FILENAME, _dataByteArray);					_preloadComplete = true;					log("preload proper finished");					if (_upToDate[GET_CATEGORIES_METHOD] || _upToDate[GET_STORIES_BY_CATEGORY_METHOD] || _upToDate[GENERIC_DATA_METHOD]) {						lastUpdateTime = new Date().getTime(); // if anything updated, reset the last update time					}					StartupController.incrementProgress(SbProgressBar.GET_MEDIA_PROG_INDEX, 1);					StartupController.incrementTotal(SbProgressBar.UPDATE_SAVED_INDEX, 1);					SpeakaboosService.getInstance().processPreloadedData();				}			}					}				private function addListeners():void {			_eventDispatcher.addEventListener(CacheLoader.MEDIA_PRELOADED, onLoadMedia);			_eventDispatcher.addEventListener(CacheLoader.MEDIA_LOAD_ERROR, onLoadMediaError);			_cacheLoader.addEventListener(IOErrorEvent.IO_ERROR , onLoadError);			_cacheLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR , onLoadError);			_cacheLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR , onLoadError);		}		private function removeListeners():void {			_eventDispatcher.removeEventListener(CacheLoader.MEDIA_PRELOADED, onLoadMedia);			_eventDispatcher.removeEventListener(CacheLoader.MEDIA_LOAD_ERROR, onLoadMediaError);			_cacheLoader.removeEventListener(IOErrorEvent.IO_ERROR , onLoadError);			_cacheLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR , onLoadError);			_cacheLoader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR , onLoadError);		}				override public function destroy():void {			removeListeners();			_cacheLoader.destroy();			_cacheLoader = null;			//TODO:call destroy() on base class?			super.destroy();					}				override protected function onNetworkStatusUpdate(event:GenericDataEvent):void {			if (_curCallback && event.data.isOnline) {				doCurLoad();			}		}	}}