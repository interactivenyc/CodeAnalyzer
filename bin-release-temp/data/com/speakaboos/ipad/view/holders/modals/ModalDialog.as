package com.speakaboos.ipad.view.holders.modals{	import com.greensock.TweenLite;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.events.ModalEvents;	import com.speakaboos.ipad.models.data.HolderChildParams;	import com.speakaboos.ipad.models.data.ModalData;	import com.speakaboos.ipad.models.data.ModalsInfo;	import com.speakaboos.ipad.utils.HtmlTextUtil;	import com.speakaboos.ipad.view.holders.CoreDisplayObjectHolder;	import com.speakaboos.ipad.view.holders.CoreMovieClipHolder;	import com.speakaboos.ipad.view.holders.components.CoreButton;	import com.speakaboos.ipad.view.holders.components.MCButton;	import com.speakaboos.ipad.view.holders.components.ModalBttn;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.InteractiveObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.text.TextField;	import flash.ui.Keyboard;				public class ModalDialog extends CoreMovieClipHolder	{		public var defaultBttn:CoreButton;		public var hasFocus:Boolean = false;		private var _modalInfo:ModalData;		private var _type:Class;				public var customObject:CoreDisplayObjectHolder;				public function ModalDialog(type:Class)		{			_type = type;			var view:MovieClip = new type() as MovieClip;			super(view);					}				public function setDialogById(pId:String, showBackBttn:Boolean = false):void {			log("setDialogById: "+pId+", "+showBackBttn);			id = pId;			_modalInfo = ModalsInfo.getModalData(id);			if (_modalInfo) {				if (_modalInfo.type === _type) {					setUpModal(showBackBttn);				} else {					log("setDialogById: "+id+" error, wrong type");				}			} else {				log("setDialogById: "+id+" error, data not found");			}		}						private function setUpModal(showBackBttn:Boolean):void		{			var defaultBttnName:String = "";			log("setUpModal for "+id);			removeAllChildHolders();			mc.gotoAndStop(_modalInfo.frame);			//			TweenLite.delayedCall(0.2, setUpModalFinish);			//		}			//		private function setUpModalFinish():void			//		{			var toDisableMouse:Object = getChildLookup();			var childParamsLst:Vector.<HolderChildParams> = new Vector.<HolderChildParams>();			if (mc.title) setTitleText(mc.title, _modalInfo.title);			var nm:String;			var tlst:Array, lst:Array = _modalInfo.texts;			var i:int,j:int;			if (lst) {				for (i=0; i<lst.length; i++) {					nm = "text_"+i;					if (lst[i] is String) // handle object with class 						setBodyText(mc[nm], lst[i]);				}			}			lst = _modalInfo.bttns;			if (lst) {				log(lst.length);				for (i=0; i<lst.length; i++) {					nm = "bttn_"+i;					delete toDisableMouse[nm];					childParamsLst.push(setUpBttn(mc[nm], lst[i]));					if (lst[i].id === ModalsInfo.OK_BTTN_ID) defaultBttnName = nm;				}			}			lst = _modalInfo.labels;			if (lst) {				log(lst.length);				for (i=0; i<lst.length; i++) {					nm = "label_"+i;					childParamsLst.push(setUpBttn(mc[nm], lst[i]));				}			}			tlst = _modalInfo.menuBttns;			if (lst) {				for (j=0; j<tlst.length; j++) {					lst = tlst[j];					for (i=0; i<lst.length; i++) {						nm = "mbttn_"+j+"_"+i;						delete toDisableMouse[nm];						childParamsLst.push(setUpBttn(mc[nm], lst[i]));					}				}			}			var clip:MovieClip;			nm = ModalsInfo.CLOSE_BTTN_ID;			clip = mc[nm];			if (clip) {				delete toDisableMouse[nm];				childParamsLst.push(setUpBttn(clip, {}));			}			nm = ModalsInfo.BACK_BTTN_ID;			clip = mc[nm];			if (clip) {				delete toDisableMouse[nm];				childParamsLst.push(setUpBttn(clip, {}));			} else {				showBackBttn = false;			}			var custObj:Object = _modalInfo.customObject;			log("custom object info "+_modalInfo.title,_modalInfo);			if (custObj) {				nm = custObj.id;				delete toDisableMouse[nm];				childParamsLst.push(setUpCustObj(mc[nm], custObj));			}			var dispObj:*;			for (nm in toDisableMouse) {				dispObj = toDisableMouse[nm] as InteractiveObject;				if (dispObj) {					dispObj.mouseEnabled = false;					dispObj = toDisableMouse[nm] as DisplayObjectContainer;					if (dispObj) dispObj.mouseChildren = false;				}			}			setupChildren(childParamsLst);			if (custObj) customObject = getHolderFromChild(custObj.id);			var bb:CoreDisplayObjectHolder = getHolderFromChild(ModalsInfo.BACK_BTTN_ID);			log("back button "+bb+", "+(bb&&bb.visible)+", "+showBackBttn);			if (bb) {				bb.visible = showBackBttn;			}			if (defaultBttnName) defaultBttn = getHolderFromChild(defaultBttnName) as CoreButton;		}				private function setUpCustObj(pMc:MovieClip, info:Object):HolderChildParams
		{			if (!pMc) throw new Error("setUpCustObj:child not found for id ="+info["id"]); 			return new HolderChildParams(pMc.name, info);
		}				override public function getData():Object { //TODO: might be collecting more than just the custom object data...			return customObject.getData();		}				private function setUpBttn(pMc:MovieClip, info:Object):HolderChildParams {			if (!pMc) throw new Error("setUpBttn:child not found for id ="+info["id"]); 			if (!info.clss) info.clss = ModalBttn; 			var func:Function = info.func || bttnClicked;			return new HolderChildParams(pMc.name, info, func); //, info.event);		}				private function getChildLookup():Object {			var result:Object = {};			var child:DisplayObject;			var i:int,n:int = mc.numChildren;			for (i=0; i<n; i++) {				child = mc.getChildAt(i);				result[child.name] = child;			}
			return result;
		}				public function bttnClicked(btn:MovieClip):void {			log("* bttnClicked "+btn.id);			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.MODAL_BTTN_CLICKED, {bttn_id: btn.id, modal_id: id, modal:this} ));		}				private function setTitleText(fld:TextField, txt:String):void {			log("* setTitleText: "+txt);			HtmlTextUtil.setFieldText(fld, txt, HtmlTextUtil.TITLE);		}				private function setBodyText(fld:TextField, txt:String):void {			HtmlTextUtil.setFieldText(fld, txt, HtmlTextUtil.BODY);			if (_type === ModalsInfo.MESSAGE_MODAL_TYPE) {				//Center Message body text vertically				fld.y = fld.y + (fld.height - fld.textHeight) / 2;			}		}				override public function onAddedToStage(e:Event = null):void{			super.onAddedToStage(e);			log("onAddedToStage " + this.id);						showBlocker();			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyboardEvent,false,0,true);			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyboardEvent,false,0,true);		}		override public function onRemovedFromStage(e:Event = null):void{			super.onRemovedFromStage(e);			log("onRemovedFromStage " + this.id);						hideBlocker();			stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyboardEvent);			stage.removeEventListener(KeyboardEvent.KEY_UP, onKeyboardEvent);		}										private function onKeyboardEvent(e:KeyboardEvent):void{			//			log("onKeyboardEvent: "+e.keyCode+", def btn "+defaultBttn+", top modal? "+(this == ModalController.topModal));						if (defaultBttn && hasFocus) {			//			if (this != ModalController.topModal) return;								/**				 * If a CoreModal declares a defaultBttn,  				 * it will respond to a KeyboardEvent.MOUSE_UP				 **/								if (e.keyCode == Keyboard.ENTER) { 					if (e.type == KeyboardEvent.KEY_DOWN){						defaultBttn.downState = true;					} else {						defaultBttn.downState = false;						defaultBttn.press(true);					}				}			}		}				public function showBlocker():void{			mc.blocker.mouseEnabled = false;			mc.blocker.visible = true;		}				public function hideBlocker():void{			mc.blocker.visible = false;		}					}}