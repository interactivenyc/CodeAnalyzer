package com.speakaboos.mobile.data.db.connection
{
	
	import com.adobe.crypto.MD5;
	import com.speakaboos.ipad.utils.debug.Logger;
	import com.speakaboos.mobile.data.db.error.GenericDbError;
	
	import flash.data.SQLConnection;
	import flash.data.SQLMode;


	
	public class ConnectionPool
	{
		
		private var _active:Vector.<ConnectionStruct>;
		private var _available:Vector.<ConnectionStruct>;
		private var _mode:String;
		
		
		public function ConnectionPool(mode:String = SQLMode.READ){
			_mode = mode;
		}
		
		
		/*********************************************************************/
		/*
			PUBLIC API
		*/
		
		
		final public function getConnection(callback:Function):void{
			
			//see if there's an available connection
			if(availableList.length){
				//log("Using existing connection: " + _mode);
				var cs:ConnectionStruct = availableList.pop();
				cs.enable();
				activeList.push(cs);
				callback(cs);
				return;
			}
			
			////////////////////////////////////////////////////////////////////
			/*  CLOSURES */
			var onGotConnection:Function = function(conn:SQLConnection):void{
				
				if(conn){
					var hash:String = getHash(_mode);
					var cs:ConnectionStruct = new ConnectionStruct(hash, conn, _mode);
					cs.enable();
					activeList.push(cs);
					callback(cs);
				}else
					callback(null);
				
			};
			/*  END CLOSURES */
			////////////////////////////////////////////////////////////////////
			
			/*  MAIN LOGIC  */
			//log("Creating new connection: " + _mode);
			//create a new connection	
			getDbConn(onGotConnection);
			
			
		}
		
		
		
		
		final public function releaseConnection(cs:ConnectionStruct, preserveLastConnection:Boolean = true):void{
			
			//log("releaseConnection: " + cs.mode + ", preserveLast: " + preserveLastConnection);
			cs.disable();
			//find the connection
			var i:int = activeList.indexOf(cs);
			if(i == -1){
				//couldn't find the connectionStruct
				//destroy it
				//log("Could not find connection " + cs.id + ", mode: " + cs.mode);
				destroyConnection(cs);
				return;
			}
			
			activeList.splice(i, 1);
			
			if(availableList.length == 0 && preserveLastConnection){
				availableList.push(cs);
			}else{
				destroyConnection(cs);
			}
			
			//log(_mode + " available connections: " + availableList.length);
			//log(_mode + " active connections: " +  activeList.length);
		}
		
		
		
		final public function destroy():void{
			//Logger.log("ConnectionPool: destroy called");
			
			destroyConnectionList(_active);
			_active = null;
			destroyConnectionList(_available);
			_available = null;
			if(ConnectionFactory.isActivated()){
				ConnectionFactory.getInstance().destroy();
			}
				
		}
		
		
		/*  END PUBLIC API */
		
		/*********************************************************************/
		
		/*  GETTERS */
				
		
		final private function get activeList():Vector.<ConnectionStruct>{
			if(!_active)
				_active = new Vector.<ConnectionStruct>();
			
			return _active;
			
		}
		
		
		final private function get availableList():Vector.<ConnectionStruct>{
			if(!_available)
				_available = new Vector.<ConnectionStruct>();
			
			return _available;
		}
		
		
		
		
		final private function getDbConnection(callback:Function):void{
			ConnectionFactory.getInstance().getConnection(callback, _mode);
		}
		
		
		/*  END GETTERS */
		
		/*********************************************************************/
		
		/*
			BEGIN PRIVATE DB Connection Methods
		*/
		
		
		/*
			Convenience function
			calls callback with database connection
		*/
		final private function getDbConn(cbFunc:Function):void{
			try{
				getDbConnection(cbFunc);
			}
			catch(err:GenericDbError){
				//Logger.log("ConnectionPool: "+ err.message);
				cbFunc(null);
			}
		}
		
		
		
		
		final private function releaseDbConnection(conn:SQLConnection):void{
			if(conn)
				ConnectionFactory.getInstance().releaseConnection(conn);
		}
		
		
		
		final private function destroyConnection(cs:ConnectionStruct):void{
			var conn:SQLConnection = cs.connection;
			cs.destroy();
			releaseDbConnection(conn);
		}
		
		
		
		final private function destroyConnectionList(list:Vector.<ConnectionStruct>):void{
			if(list){
				for(var i:int = list.length - 1; i >= 0; i--){
					var cs:ConnectionStruct = list.pop();
					destroyConnection(cs);
				}
			}
		}
		
		/*
			END PRIVATE DB Connection Methods
		*/
		
		/*********************************************************************/
		
		/*  UTILITY FUNCTIONS */
		
		final private function getHash(mode:String):String{
			/*
			var b:ByteArray = flash.crypto.generateRandomBytes(10);
			var s:String = b.toLocaleString();
			
			//var s:String = WSSEUsernameToken.getUsernameToken(Math.random().toString(),mode);
			Logger.log("Generated byte string: '" + s + "'");
			return s;
			*/
			var r:String = Math.random().toString();
			var strDate:String = new Date().getTime().toString();
			
			//Logger.log("Generated date string: '" + strDate + "'");
			//Logger.log("Generated random numeral string: '" + r + "'");
			
			var hash:String = MD5.hash(r + mode + strDate);
			//Logger.log("Generated hash string: '" + hash + "'");
			
			return hash;
		}
		
		
		final private function log(str:String=""):void{
			str = "[ConnectionPool] " + str;
			Logger.log(str);
		}
		
		/*  END UTILITY FUNCTIONS */
		
		/*********************************************************************/
		
	}
}

