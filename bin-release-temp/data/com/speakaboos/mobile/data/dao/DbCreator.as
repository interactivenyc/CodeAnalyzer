package com.speakaboos.mobile.data.dao{	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.mobile.data.db.connection.ConnectionStruct;	import com.speakaboos.mobile.data.db.error.GenericDbError;		import flash.data.SQLMode;	import flash.data.SQLResult;	import flash.data.SQLStatement;
		public class DbCreator extends CoreDao	{				//local database schema		public static const DB_SCHEMA_VERSION:String = "1.0.0";				//private var _dbConn:SQLConnection;		private var _callback:Function;		private var _connectionStruct:ConnectionStruct;				public function DbCreator(){}						public function createDatabase(cbFunc:Function):void{						//log(this,"CreateDatabase -> get connection");						_callback = cbFunc;						//first check to see if the db already exists			//if not, try copying the existing empty db file from the app bundle			//if that fails, create the db									var cbf:Function = function(cs:ConnectionStruct):void{				if(cs != null){					connection = cs;					createUserTable();				}else{					onComplete(false);				}			};						getConnection(cbf,SQLMode.CREATE);		}						override public function destroy():void{			release();		}				final private function set connection(cs:ConnectionStruct):void{			_connectionStruct = cs;		}				final private function get connection():ConnectionStruct{			return _connectionStruct;		}				/*		final private function set conn(conn:SQLConnection):void{			_dbConn = conn;		}				final private function get conn():SQLConnection{			return _dbConn;		}		*/							/*		//NOT USED ANYMORE		private function rollback(conn:SQLConnection):Boolean{						//conn.rollback();			//conn.close();						return false;		}		*/								final private function createUserTable():void{			//log("createUserTable");			log(this,"createUserTable");						var sql:String =  "CREATE TABLE IF NOT EXISTS users (" +				"    id INTEGER PRIMARY KEY AUTOINCREMENT, " +				"    user_id TEXT," +				"    session TEXT," +				"	 fb_id TEXT," +				"    firstname TEXT," +				"    lastname TEXT," +				"    email TEXT," +				"    subscription_type TEXT," +				"    subscription_state TEXT," +				"    days_left INTEGER," +				"    free_trial_used TEXT," +				"    expiration_date_seconds INTEGER," +				"	 expiration_date TEXT," +				"	 seconds_left INTEGER," +				"	 update_time INTEGER" +				")";						//log(this, sql);						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = connection.connection;						runStatement(stmt, createStoriesTable, onError);		}								final private function createStoriesTable():void{			//log(this, "createStoriesTable");						var sql:String =  "CREATE TABLE IF NOT EXISTS stories (" +				"    id INTEGER PRIMARY KEY AUTOINCREMENT, " +				//"    update_time INTEGER, " +				"    slug TEXT," +				"    title TEXT," +				"    category TEXT," +				"    categoryType TEXT," +				"    filename TEXT," +				"    dataURL TEXT," +				"    assetURL TEXT," +				"    timestamp TEXT," +				"    storyType TEXT," +				"    thumbnail TEXT," +				"    freeStory INTEGER" +				")";						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = connection.connection;						runStatement(stmt, addStoriesIndex, onError);				}						final private function addStoriesIndex():void{			/*			add a unique index on the slug column 			in the Stories Table			*/						//log("adding unique index on the slug column of stories table");			//log(this, "addStoriesIndex");						var sql:String =  "CREATE UNIQUE INDEX IF NOT EXISTS stories_slug_unique ON stories (slug)";						//log(this, sql);						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = connection.connection;				runStatement(stmt, createCategoryTable, onError);				}				/*		//NO LONGER USED		private function createSettingsTable(conn:SQLConnection):Boolean{						log(this, "createSettingsTable");						var sql:String =         "CREATE TABLE IF NOT EXISTS settings (" +				"    id INTEGER PRIMARY KEY AUTOINCREMENT, " +				"    user_name TEXT," +				"    story_videos TEXT," +				"    swf_videos TEXT" +				")";						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = conn;						  runStatement(stmt, addCategoryTableIndexes, onError);		}	 		*/				final private function createCategoryTable():void		{			//log(this, "createCategoryTable");						var sql:String =         "CREATE TABLE IF NOT EXISTS categories (" +				"    id INTEGER PRIMARY KEY AUTOINCREMENT, " +				"    slug TEXT," +				"    category TEXT" +				")";						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = connection.connection;						runStatement(stmt, addCategoryTableIndex1, onError);		}							final private function addCategoryTableIndex1():void		{			//log(this, "addCategoryTableIndex1");							var stmt:SQLStatement = new SQLStatement();			stmt.text =  "CREATE INDEX IF NOT EXISTS categories_slug_idx ON categories (slug)";			stmt.sqlConnection = connection.connection;						runStatement(stmt, addCategoryTableIndex2, onError);					}					final private function addCategoryTableIndex2():void		{			//log(this, "addCategoryTableIndex2");						var stmt:SQLStatement = new SQLStatement();			stmt.text = "CREATE INDEX IF NOT EXISTS categories_category_idx ON categories (category)";			stmt.sqlConnection = connection.connection;						runStatement(stmt, createMetaTable, onError);		}				final private function createMetaTable():void{			//log(this, "createCategoryTable");						var sql:String =  "CREATE TABLE IF NOT EXISTS meta (" +				"    id INTEGER PRIMARY KEY AUTOINCREMENT, " +				"    schema_version TEXT" +				")";						var stmt:SQLStatement = new SQLStatement();			stmt.text = sql;			stmt.sqlConnection = connection.connection;						runStatement(stmt, insertSchemaVersion, onError);		}				final private function insertSchemaVersion():void{			//INSERT OR REPLACE into meta (id, schema_version) values((SELECT id from meta ORDER BY id DESC LIMIT 1), "1.0.0");			log(this,"insertSchemaVersion");			log(this, "schema version: " + DB_SCHEMA_VERSION);						var sql:String =  'INSERT OR REPLACE into meta (id, schema_version) values((SELECT id from meta ORDER BY id DESC LIMIT 1), :schemaVer)';						var stmt:SQLStatement = new SQLStatement();			stmt.parameters[':schemaVer'] = DB_SCHEMA_VERSION;			stmt.text = sql;			stmt.sqlConnection = connection.connection;						runStatement(stmt, onDbCreated, onError);		}				final private function onDbCreated():void{			//log(this, "onDbCreated");			onComplete(true);		}				final private function onError(str:String):void{			log(this, "Error occurred creating the Database");			onComplete(false);		}				final private function onComplete(success:Boolean):void{			release();			_callback(success);		}						final private function release():void{			releaseConnection(_connectionStruct);			_connectionStruct = null;		}								final private function runStatement(stmt:SQLStatement, successFunc:Function, errFunc:Function):void{						try{				var cbFunc:Function = function(result:SQLResult):void{					//log(this,"runStatement -> cbFunc called => SUCCESS!");					successFunc();				};								CoreDao.execute(stmt,cbFunc);							}catch(err:GenericDbError){				log(this,"An error occurred: " + err.message);				errFunc(err.message);			}catch(err:Error){				log(this,"An error occurred: " + err.message);				errFunc(err.message);			}				}					}}