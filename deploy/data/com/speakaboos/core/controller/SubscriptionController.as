package com.speakaboos.core.controller{		import com.adobe.utils.DictionaryUtil;	import com.milkmangames.nativeextensions.ios.events.StoreKitEvent;	import com.speakaboos.core.CoreEventUser;	import com.speakaboos.core.events.AppEvents;	import com.speakaboos.core.events.CoreEventDispatcher;	import com.speakaboos.core.events.GenericDataEvent;	import com.speakaboos.core.events.LoginEvents;	import com.speakaboos.core.events.ModalEvents;	import com.speakaboos.core.events.SubscriptionEvents;	import com.speakaboos.core.models.data.ErrorStruct;	import com.speakaboos.core.models.data.ModalsInfo;	import com.speakaboos.core.models.data.UserProfile;	import com.speakaboos.core.models.data.product.ITunesTransaction;	import com.speakaboos.core.models.impl.UserProfileImpl;	import com.speakaboos.core.models.impl.enum.SubscriptionStatusEnum;	import com.speakaboos.core.models.services.LoginService;	import com.speakaboos.core.models.services.NetworkMonitor;	import com.speakaboos.core.models.services.SpeakaboosService;	import com.speakaboos.core.models.services.StoreKitService;	import com.speakaboos.core.models.services.SubscriptionService;	import com.speakaboos.core.utils.HtmlTextUtil;	import com.speakaboos.story.utils.ObjectUtils;	import com.speakaboos.core.utils.Validation;	import com.speakaboos.mobile.ios.service.error.StoreKitServiceError;		import flash.utils.Dictionary;
		public class SubscriptionController extends CoreEventUser	{				private var _appController:AppController;		private var _dictRestoredPurchases:Dictionary;				private var _numRestored:uint = 0;		private var _numToRestore:uint = 0;				public function SubscriptionController(appController:AppController)		{			log("SubscriptionController");			_appController = appController;			init();		}				final private function init():void {			_eventDispatcher.addEventListener(SubscriptionEvents.RESTORE_TRANSACTIONS, restoreTransactions);			_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_TRANSACTIONS_RESTORED, onITunesTransactionsRestored);			_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_SUCCEEDED, onITunesTransactionRestoreSucceeded);			_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_FAILED, onITunesTransactionRestoreFailed);			_eventDispatcher.addEventListener(SubscriptionEvents.SUBSCRIBE_RESTORE_SUCCEEDED, onRestoreSpeakITunesPurchaseSucceeded);			_eventDispatcher.addEventListener(SubscriptionEvents.SUBSCRIBE_RESTORE_FAILED, onRestoreSpeakITunesPurchaseFailed);			_eventDispatcher.addEventListener(SubscriptionEvents.SUBSCRIBE_SUCCEEDED, onSubscribeSucceeded);			_eventDispatcher.addEventListener(SubscriptionEvents.SUBSCRIBE_FAILED, onSubscribeFailed);						_eventDispatcher.addEventListener(SubscriptionEvents.SUBSCRIBE_CONNECTION_ERROR, onSessionCreatedError);						_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_SUCCEEDED, onITunesSubscribeSucceeded);			_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_FAILED, onITunesSubscribeFailed);			_eventDispatcher.addEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_CANCELLED, onITunesSubscribeCancelled);						initStoreKit();					}				override public function destroy():void {			log("destroy");			_eventDispatcher.removeEventListener(SubscriptionEvents.RESTORE_TRANSACTIONS, restoreTransactions);			_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_TRANSACTIONS_RESTORED, onITunesTransactionsRestored);			_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_SUCCEEDED, onITunesTransactionRestoreSucceeded);			_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_FAILED, onITunesTransactionRestoreFailed);			_eventDispatcher.removeEventListener(SubscriptionEvents.SUBSCRIBE_RESTORE_SUCCEEDED, onRestoreSpeakITunesPurchaseSucceeded);			_eventDispatcher.removeEventListener(SubscriptionEvents.SUBSCRIBE_RESTORE_FAILED, onRestoreSpeakITunesPurchaseFailed);				_eventDispatcher.removeEventListener(SubscriptionEvents.SUBSCRIBE_SUCCEEDED, onSubscribeSucceeded);			_eventDispatcher.removeEventListener(SubscriptionEvents.SUBSCRIBE_FAILED, onSubscribeFailed);						_eventDispatcher.removeEventListener(SubscriptionEvents.SUBSCRIBE_CONNECTION_ERROR, onSessionCreatedError);						_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_SUCCEEDED, onITunesSubscribeSucceeded);			_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_FAILED, onITunesSubscribeFailed);			_eventDispatcher.removeEventListener(SubscriptionEvents.ITUNES_SUBSCRIBE_CANCELLED, onITunesSubscribeCancelled);						removeSessionListeners();							clear();			destroyStoreKit();						//_restoredPurchases = null;			super.destroy();		}						final public function getDialogEventFromStatus(subState:String, storiesViewed:int):GenericDataEvent{						/*			Steps to take:									1. Check subscription state			2. If active, check to see if user is a RETURNING_USER or a FREE_TRIAL_USER			3. If FREE_TRIAL_USER, present welcome dialog if no stories have been downloaded			4. If RETURNING_USER (subscriber), do nothing			5. If subscription is expired, present SUBSCRIPTION blocker						*/						var event:GenericDataEvent;//			var msgHead:String;//			var msgBody:String;//			var buttons:Vector.<DialogButtonBase>;//			var button:DialogButtonBase;//			var defaultButton:DialogButtonBase;						//var thisUser:UserProfile = _appController.getUserProfile();						switch(subState){								case SubscriptionStatusEnum.RETURNING_USER:					//returning subscriber										//var handle:String = _appController.getUserProfileImpl().getHandle();													event = null;										break;										case SubscriptionStatusEnum.FREE_TRIAL_USER:				 	//User has valid session and free trial subscription"					//show number of days until free trial is over					//and allow to continue free trial					//var daysLeft:String = thisUser.days_left;					//event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.FULL_SUBSCRIPTION});//					log("free trial user.  Stories viewed: " + storiesViewed);//					if(storiesViewed && storiesViewed >= 1){//						log("storiesviewed >= 1");//						event = null;//					}//					else{//						log("storiesviewed: " + storiesViewed);//						event = new GenericDataEvent(AppEvents.PLAY_WELCOME_VIDEO);//					}										event = null;										break;				/*				case UserProfileImpl.NEW_TRIAL_NOT_USED:					//User is new user without free trial					//new user					//allow to start free trial					event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.WELCOME_ID, clearStack:true});//					msgHead = "New User";//					msgBody = "Congrats and welcome to your 30 day free trial.  We hope you enjoy all that Speakaboos has to offer.";										break;				*/				/*				case UserProfileImpl.NEW_TRIAL_USED:					//User has already used free trial					//show subscription dialog					event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.TRIAL_OVER_ID});										break;				*/				/*				case UserProfileImpl.EXPIRED_TRIAL_USED:					//expired subscriber					//free trial used					event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIBE__TRIAL_EXPIRED_ID});					break;								case UserProfileImpl.EXPIRED_TRIAL_NOT_USED:										// expired subscriber					// who hasn't used free trial					event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIBE__TRIAL_EXPIRED_ID});					break;				*/								case SubscriptionStatusEnum.SUBSCRIPTION_EXPIRED:					event = new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_EXPIRED_BLOCKER_ID, clearStack:true});					break;														/*				no dialog for the states below				*/								case SubscriptionStatusEnum.STATUS_UNKNOWN:				case UserProfileImpl.INVALID_SESSION:					//invalid session									default:				 event  = null;								}						return event;		}				/************************************************************************/		/*		core logic		*/		/************************************************************************/						final public function restoreTransactions():void{			log("restoreTransactions");			if(!NetworkMonitor.getInstance().isOnline){				//show offline modal				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.NEED_CONNECTION_ID}));				return;			}						log("_loginController: "+ _appController._loginController);			//check for session			if(!_appController._loginController.sessionIsValid()){				addSessionListeners();				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_LOADER));					_appController._loginController.getNewSession();				return;			}						doRestoreTransactions();					}				final private function doRestoreTransactions():void{					var storeSvc:StoreKitService = StoreKitService.getInstance();			if(StoreKitServiceError.STOREKIT_ENABLED != storeSvc.enable()){				log("could not enable storekit service");				storeSvc = null;				StoreKitService.destroySingleton();				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.UNABLE_TO_CONNECT_TO_APP_STORE_ID}));				return;			}									/*			if(_restoredPurchases)			_restoredPurchases.length = 0; //clear the vector			else			_restoredPurchases = new Vector.<ITunesTransaction>();			*/						if(!_dictRestoredPurchases){				_dictRestoredPurchases = new Dictionary();			}						_numRestored = 0;						_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_LOADER));				storeSvc.restoreTransactions();				}				final private function moreToRestore():Boolean{						/*			if(!(_restoredPurchases && _restoredPurchases.length))				return false;			*/						return ((_numRestored < _numToRestore) && (DictionaryUtil.getKeys(_dictRestoredPurchases).length > 0));				//return true;						//return false;		}				/************************************************************************/		/*		iTunes Callbacks -- Single Transaction		*/		/************************************************************************/				private function onITunesSubscribeSucceeded(e:*):void{			log("onITunesSubscribeSucceeded");			//StoreKitService.getInstance().createSpeakITunesSubscription(e.data.messageData,_appController.getUserProfile());			SubscriptionService.getInstance().createITunesSubscription(e.data.messageData, LoginService.getInstance().getUserProfile());		}								private function onITunesSubscribeFailed(e:*):void{			hideLoader();			log("itunes subscription failed: " + e.data.messageData);			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));					}				private function onITunesSubscribeCancelled(e:*):void{			log("transaction cancelled");			hideLoader();		}				/************************************************************************/		/*		iTunes Callbacks -- Restore Transactions		*/		/************************************************************************/						final private function onITunesTransactionRestoreSucceeded(e:GenericDataEvent):void{						log("onITunesTransactionRestoreSucceeded");						var ske:StoreKitEvent = e.data.messageData as StoreKitEvent;						log("productID: " + ske.productId);			log("original transID:" + ske.originalTransactionId);			log("transactionID: " + ske.transactionId);			//log("receipt: " + ske.transactionId);						var iTunesTrans:ITunesTransaction = new ITunesTransaction(ske);			var keyID:String = iTunesTrans.originalTransID;			if(keyID == null || keyID  == "null"){				log("**** original transID was null... ignoring this transaction ****");				return;			}						if(_dictRestoredPurchases[keyID] == null){				_dictRestoredPurchases[keyID] = Vector.<ITunesTransaction>([iTunesTrans]);			}			else{				var vect:Vector.<ITunesTransaction> = _dictRestoredPurchases[keyID];				vect.push(iTunesTrans);			}			//_restoredPurchases.push(iTunesTrans);						//StoreKitService.getInstance().createSpeakITunesSubscription(e.data.messageData,_appController.getUserProfile());		}				final private function onITunesTransactionRestoreFailed(e:GenericDataEvent):void{			log("onITunesTransactionRestoreFailed");			//_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));							onRestoreSpeakITunesPurchaseFailed(e);		}						final private function onITunesTransactionsRestored(e:GenericDataEvent):void{			/*				StoreKit is done restoring transactions.  Now, send those transactions to the speakaboos server			*/			log("onITunesTransactionsRestored");//			destroyStoreKit();						_numToRestore = DictionaryUtil.getKeys(_dictRestoredPurchases).length;			if(_numToRestore > 0){				//now, transmit the restored transactions to the server				restoreSpeakITunesPurchases();			}else{				clear();				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.RESTORE_PURCHASES_EMPTY_ID}));			}					}						final private function restoreSpeakITunesPurchases():void{						//initialize the restore purchases process			_numRestored = 0;						//start the process			doRestoreSpeakITunesPurchases();					}						final private function doRestoreSpeakITunesPurchases():void{			log("Transactions Restored: " + _numRestored);			//if(moreToRestore()){								var trans:ITunesTransaction;								_numRestored++;				for(var theKey:String in _dictRestoredPurchases){					//get a single key/value pair from the dictionary and exit the loop										trans = null;										log("Restoring original transaction:" + theKey);					var vect:Vector.<ITunesTransaction> = _dictRestoredPurchases[theKey];					if(vect.length > 0){						//trans = vect[vect.length-1];//grab the last one in the list (probably the most recent one)						trans = getMostRecentTransaction(vect);					}else{						log("ITunesTransaction vector was empty");					}										vect.length = 0;					vect = null;					delete _dictRestoredPurchases[theKey];					break; //exit the loop after a single iteration									}								if(trans && Validation.isPopulated(trans.originalTransID) && Validation.isPopulated(trans.receipt)){					SubscriptionService.getInstance().restoreITunesSubscription(LoginService.getInstance().getUserProfile(), trans);				}				else{					log("could not retrieve transaction from vector!!!");					if(moreToRestore()){						doRestoreSpeakITunesPurchases();					}else{						_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.SUBSCRIBE_RESTORE_FAILED,{error:"ITunesTransaction vector was empty"}));						}				}						}						final private function onRestoreSpeakITunesPurchaseSucceeded(e:GenericDataEvent):void{			log("**********************************");			log("*** onRestoreSpeakITunesPurchaseSucceeded")			log("**********************************");						var userProfile:UserProfile = e.data.userProfile as UserProfile;			LoginService.getInstance().setUserProfile(userProfile);			LoginService.getInstance().saveUserToDB();						if(moreToRestore())			{doRestoreSpeakITunesPurchases();}			else			{restoreSpeakITunesPurchasesDone(userProfile);}														}				final private function onSubscribeSucceeded(e:GenericDataEvent):void{			log("**********************************");			log("*** moved from AppController receiveEvent");			log("**********************************");									var jsonData:Object = e.data.messageData;			var u:UserProfile = LoginService.getInstance().getUserProfile();//new UserProfile();			u.initWithData(jsonData);			//update db			//					log("saving subscription status to db");			LoginService.getInstance().saveUserToDB();						//complete the transaction with iTunes			var trans:String = ObjectUtils.getSafeParameter(jsonData.response, "transaction");			//var trans:String = jsonData.response.transaction;			if(Validation.isPopulated(trans)){				StoreKitService.getInstance().finishManualTransaction(trans);				_appController.appStateUpdated();								CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));				if(!UserProfileImpl.getInstance().hasEmail()){					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.COMPLETE_ACCOUNT_ID, clearStack:true}));				}				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_SUCCEEDED_ID}));							}else{				//unkown error: there's no transaction ID!				HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(u, trans)};				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));			}		}								final private function onRestoreSpeakITunesPurchaseFailed(e:GenericDataEvent):void{			log("**********************************");			log("*** onRestoreSpeakITunesPurchaseFailed");			log("**********************************");						clear();			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.ERROR_RESTORE_PURCHASES_ID}));		}				final private function onSubscribeFailed(e:GenericDataEvent):void{			var errorObj:Object = e.data.error as Object;			handleFailedSubscription(errorObj);		}						final private function restoreSpeakITunesPurchasesDone(u:UserProfile):void{						log("**********************************");			log("*** restoreSpeakITunesPurchasesDone");			log("**********************************");			//remove listeners						clear();			//remove loader			//_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));						if(UserProfileImpl.getInstance().subscriptionHasExpired()){				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_EXPIRED_BLOCKER_ID, clearStack:true}));			}			else{			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.RESTORE_PURCHASES_SUCCEEDED_ID}));			}						_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.USER_DATA_UPDATED));								}				final private function getMostRecentTransaction(vect:Vector.<ITunesTransaction>):ITunesTransaction{			//extract the transaction with the highest transactionID			//return null if none is found						var lastTrans:ITunesTransaction;			var lastID:String = "";			var len:int = vect.length;			if(len > 0){				for(var i:int = 0; i < len; i++){					if(lastID < vect[i].transactionID){						lastID = vect[i].transactionID;						lastTrans = vect[i];					}				}			}						return lastTrans;				}				final private function clear():void{					//clear the vector			/*			if(_restoredPurchases){				_restoredPurchases.length = 0;			}						_restoredPurchases = null;			*/			_numRestored = 0;			_numToRestore = 0;						if(_dictRestoredPurchases){				for(var thisKey:String in _dictRestoredPurchases){					var vect:Vector.<ITunesTransaction> = _dictRestoredPurchases[thisKey];					vect.length = 0;					vect = null;					delete _dictRestoredPurchases[thisKey];				}			}						_dictRestoredPurchases = null;						//destroyStoreKit();					}				final private function initStoreKit():void{			var str:String = StoreKitService.getInstance().enable();			if(str == StoreKitServiceError.NOT_SUPPORTED){				StoreKitService.destroySingleton();			}		}				final private function destroyStoreKit():void {			StoreKitService.destroySingleton();		}				final private function restoreDone():void{			subscribeDone();		}				final private function subscribeDone():void{			clear();		}								final private function closeModal():void {			_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_MODAL));		}						/************************************************************************/		/* session related stuff */		/************************************************************************/		final private function addSessionListeners():void{			_eventDispatcher.addEventListener(AppEvents.LOGIN_SUCCESS, onSessionCreated);			_eventDispatcher.addEventListener(AppEvents.LOGIN_ERROR, onSessionCreatedError);			_eventDispatcher.addEventListener(LoginEvents.CONNECTION_ERROR, onSessionCreatedError);		}				final private function removeSessionListeners():void{			_eventDispatcher.removeEventListener(AppEvents.LOGIN_SUCCESS, onSessionCreated);			_eventDispatcher.removeEventListener(AppEvents.LOGIN_ERROR, onSessionCreatedError);			_eventDispatcher.removeEventListener(LoginEvents.CONNECTION_ERROR, onSessionCreatedError);		}				final private function onSessionCreated(e:GenericDataEvent):void{			log("Successfully received new session!");			log("Continuing with Restore Purchase!");			removeSessionListeners();			doRestoreTransactions();		}						final private function onSessionCreatedError(e:GenericDataEvent):void{			removeSessionListeners();			hideLoader();			if (StartupController.introFinished) {				//display appropriate modal				_eventDispatcher.dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.NETWORK_ERROR_ID}));			} else {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));			}		}				/************************************************************************/		/* moved from AppController */		/************************************************************************/						public function doSubscriptionFlow():void{			log("*** doSubscriptionFlow StartupController.introFinished: "+StartupController.introFinished);			hideLoader();						log("* doSubscriptionFlow");			var subStatus:String = UserProfileImpl.getInstance().getSubscriptionStatus();			log("Subscription status: " + subStatus+", "+StartupController.introFinished);						var event:GenericDataEvent = getDialogEventFromStatus(subStatus,SpeakaboosService.getInstance().savedStoryCount);			_appController.appStateUpdated();			if (event) {				//				log("dispatching event...");				//enterDebugger();				if (StartupController.introFinished) {					CoreEventDispatcher.getInstance().dispatchEvent(event);				} else {					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));				}			} else {								/*				these states don't get handled by getDialogFromStatus() above				handle them ourselves				*/				switch (subStatus) {					case SubscriptionStatusEnum.FREE_TRIAL_USER:					case SubscriptionStatusEnum.RETURNING_USER:						if (!StartupController.introFinished) {							CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));						}						break;										case UserProfileImpl.INVALID_SESSION:					case SubscriptionStatusEnum.STATUS_UNKNOWN:						//invalid session						//return to login screen					default:						//log("Default subscription behavior. Show login screen");						//return to login screen						_appController._loginController.doInvalidSession();										}			}		}						final private function getSubscriptionErrorString(up:UserProfile, orderId:String):String{			var msgStr:String = ( (Validation.isPopulated(up.email) ? " Account: " + up.email : "") + (Validation.isPopulated(up.user_id) ? " User ID: " + up.user_id : "") + (Validation.isPopulated(orderId) ? " Order Number: " + orderId : ""));			return msgStr;		}								final private function handleFailedSubscription(errorObj:Object):void{						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));						var up:UserProfile = ((errorObj.userProfile != null) ? errorObj.userProfile : null) as UserProfile;			var error:ErrorStruct = errorObj.error as ErrorStruct;			var transId:String = errorObj.appleTID as String;			var orderId:String = errorObj.speakTID as String;						var finishTrans:Function = function():void{				if(Validation.isPopulated(transId)){					StoreKitService.getInstance().finishManualTransaction(transId);				}			}						log("handleFailedSubscription");			log("Error code: " + error.code);			log("Transaction: " + transId);			log("Order ID (internal trans id): " + orderId);			if(up){				log("userProfile, id: " + up.user_id + ", email: "  + up.email);			}else{				log("userProfile: null");			}						switch(error.code){				/*					Error code list:					https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html#//apple_ref/doc/uid/TP40010573-CH104-SW2				*/								case 21000:				case 21002:				case 21003:				case 21004:				case 21007:				case 21008:				case 21020: //21020: Any other itunes verification error 					//subscription error returned by Apple					//finish the transaction					finishTrans();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_APP_STORE_FAILED_ID}));					break;								case 21005:					//apple server is down					//alert user, but keep subscription in queue					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_APP_STORE_DOWN_ID}));										break;								case 21006:					//subscription has expired					finishTrans();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_EXPIRED_BLOCKER_ID, clearStack:true}));					break;								case 501:				case 405:					/*					501 Missing session or receipt parameter; 					405 Invalid session; 					*/					//finishTrans();					HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(up, orderId)};					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));						break;								case 21030:					//receipt is valid, but speakaboos error occurred					//same as default behavior				default:					//speakaboos related error					//apple validation succeeded, complete the transaction					//finishTrans();					HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(up, orderId)};					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));								}						//update the database and notify the app			if(up){				LoginService.getInstance().setAndSaveUserProfile(up);				_appController.appStateUpdated();			}			}					}}