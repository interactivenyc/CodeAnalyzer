package com.speakaboos.ipad.controller{	import com.greensock.TweenLite;	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.CoreEventDispatcher;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.models.impl.UserProfileImpl;	import com.speakaboos.ipad.models.services.CacheDataService;	import com.speakaboos.ipad.models.services.LoginService;	import com.speakaboos.ipad.models.services.NetworkMonitor;	import com.speakaboos.ipad.models.services.PreloadService;	import com.speakaboos.ipad.models.services.SpeakaboosService;	import com.speakaboos.ipad.models.services.StoreKitService;	import com.speakaboos.ipad.models.services.StoryDbService;	import com.speakaboos.ipad.models.services.SubscriptionService;	import com.speakaboos.ipad.utils.HtmlTextUtil;	import com.speakaboos.ipad.utils.MovieClipUtils;	import com.speakaboos.ipad.utils.debug.Logger;	import com.speakaboos.ipad.view.BookView;	import com.speakaboos.ipad.view.holders.CoreMovieClipHolder;	import com.speakaboos.ipad.view.holders.components.ProgressBar;	import com.speakaboos.ipad.view.holders.components.SbProgressBar;	import com.speakaboos.mobile.data.dao.DbCreator;	import com.speakaboos.story.events.CentralEventDispatcher;	import com.speakaboos.story.events.StoryEvent;		import flash.debugger.enterDebugger;	import flash.desktop.NativeApplication;	import flash.desktop.SystemIdleMode;	import flash.display.FrameLabel;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageQuality;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TouchEvent;	import flash.geom.Point;		import net.hires.debug.Stats;
		public class StartupController extends CoreMovieClipHolder	{//		private var _videoPlayer:VideoPlayer;		public static const WIDTH:int=1200;		public static const HEIGHT:int=900;//		public static const TITLE_ANIM_DONE_LABEL:String = "titleAnimDone";		private var _titleAnimDoneFrame:int;				public var bookOpen:MovieClip;		public var bookClosed:MovieClip;		public var bg:MovieClip;		public var main:MovieClip;		private var _introAnim:MovieClip;		private var _progBar:SbProgressBar;		private var _preloader:PreloadService;//		private static var _skipIntro:Boolean = AppConfig.DEBUG_MODE; //		private static var _skipIntro:Boolean = true;		private static var _skipIntro:Boolean = false;		private static var _updateAvailable:Boolean = false;		private static var MIN_UPDATE_CHECK_TIME:Number = 1000 * 60 * 60 * 24; //last number is hours , chqnge to 24 for a day between update checks.		private static var MIN_IN_BACKGROUND_CHECK_TIME:Number = 1000 * 60 * 60 * 1; // min time in background before move to forground will trigger update		private static var _resetPending:Boolean = false;		private static var _lastBackgroundTime:Number;		private var _introAnimFinished:Boolean;				public static var introFinished:Boolean = false;				public function StartupController(pMc:MovieClip)		{			super(pMc);			log("*****************************************");			log("*** constructor");			log("*****************************************");			init();		}				private function init():void {			//stage.align = StageAlign.TOP_RIGHT;			stage.scaleMode = StageScaleMode.SHOW_ALL;			stage.quality = StageQuality.MEDIUM; // .HIGH; //						main = mc.main;			bg = main.bg;			bookOpen = main.bookOpen;			bookClosed = main.bookClosed;			bookOpen.visible = false;			HtmlTextUtil.init();						if (AppConfig.DEBUG_MODE) {				MIN_UPDATE_CHECK_TIME = 2 * 60 * 1000; ///set update check to 2 min for testing				MIN_IN_BACKGROUND_CHECK_TIME = 0.2 * 60 * 1000; // set min in backgound before update trigger = 12 sec for testing			}						addListeners();			NetworkMonitor.getInstance();			AppController.getInstance();						start();		}				private function addListeners():void {			addEventListener( Event.ACTIVATE, onAppInForeground );			addEventListener( Event.DEACTIVATE, onAppInBackground);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.FULL_RESET, reset);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHANGE_VIEW_MODE, hideGraphics);		}				private function removeListeners():void {			removeEventListener( Event.ACTIVATE, onAppInForeground );			removeEventListener( Event.DEACTIVATE, onAppInBackground);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.FULL_RESET, reset);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHANGE_VIEW_MODE, hideGraphics);		}				private function hideGraphics(e:GenericDataEvent=null):void{			log("* hideGraphics");			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHANGE_VIEW_MODE, hideGraphics);			//			bookOpen.visible = false;//			bookClosed.visible = false;//			bg.visible = false;			mc.parent.removeChild(mc);			mc = null;		}		private function start():void {			_introAnimFinished = false;			log("* start _skipIntro, debugMode: "+_skipIntro+", "+AppConfig.DEBUG_MODE)			initPreload();		}				private function initAnim():void{			log("* initAnim");			killIntroAnim();			_introAnim = new IntroAnimation();			_introAnim.x = 600;			_introAnim.y = 450;			_titleAnimDoneFrame = _introAnim.totalFrames;			_introAnim.addFrameScript(_titleAnimDoneFrame - 1, animFinished);			addChild(_introAnim);			if (_skipIntro) {				_introAnim.gotoAndStop(_titleAnimDoneFrame);				showProgBar();			} else {				_introAnim.addEventListener(MouseEvent.MOUSE_DOWN, animFinished);			}		}		//		private function pauseAnim(): void {//			_introAnim.gotoAndStop(_titleAnimDoneFrame);//			if (_progBar.progress < 1) {//				showProgBar();//			} else {//				checkIntroDone();//			}//		}//				private function animFinished(e:MouseEvent=null):void{			log("* animFinished");			_introAnimFinished = true;			_introAnim.gotoAndStop(_titleAnimDoneFrame);			if (_progBar.progress < 1) {				showProgBar();			} else {				checkIntroDone();			}		}				public static function incrementProgress(index:int, val:int):void {			if (val > 0) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ProgressBar.UPDATE_PROGRESS, {index:index, type:ProgressBar.COMPLETED_TYPE, val:val, increment:true}));			}		}				public static function incrementTotal(index:int, val:int):void {			if (val > 0) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ProgressBar.UPDATE_PROGRESS, {index:index, type:ProgressBar.TOTAL_TYPE, val:val, increment:true}));			}		}				private function initPreload():void {			_progBar = new SbProgressBar();			incrementTotal(SbProgressBar.DB_VERIFICATION_PROG_INDEX, 1);			log("* initPreload");			//refactored db creation			// this is being done here because, since it is async, it might not finish before preload is done, even though it was always initiated in this class...			var dbc:DbCreator = new DbCreator();			dbc.createDatabase(onDbCreated);		}				private function onDbCreated(success:Boolean):void { 			log("*onDbCreated ");			//TODO: handle failure (was not checking this when in AppController either			StoryDbService.getInstance(); //init db instance, but don't need the instance here			incrementProgress(SbProgressBar.DB_VERIFICATION_PROG_INDEX, 1);			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;			CoreEventDispatcher.getInstance().addEventListener(AppEvents.PRELOAD_COMPLETE, preloadComplete);				_preloader = new PreloadService();			initAnim(); 		}				private function showProgBar():void {			log("* showProgBar "+Boolean(_preloader));			if (!contains(_progBar) && (_progBar.progress < 1)) {				addChild(_progBar);				MovieClipUtils.centerDisplayObject( _progBar.view, new Point(17, 112)); //x was 34			}		}				private function removeProgBar():void {			if (_progBar) {				removeChild(_progBar.view);				_progBar.destroy();				_progBar = null;			}		}				protected function preloadComplete(event:GenericDataEvent):void {			log("* preloadComplete");			// either the animation is still going, so we let that finish, else go onto the main menu			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.PRELOAD_COMPLETE, preloadComplete);			_preloader.destroy();			_preloader = null;			StartupController.incrementProgress(SbProgressBar.UPDATE_SAVED_INDEX, 1);			NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.NORMAL;			AppController.getInstance().visible = false;			mc.parent.addChild(AppController.getInstance());			if (!_introAnim) {				bookClosed.gotoAndStop("textHilite");			}						checkSession();		}				private function reset(e:GenericDataEvent=null):void {//			removeChild(controller);			//destroy();			_skipIntro = true;			Main.start();		}				private function playWelcomeVideo():void{			log("* playWelcomeVideo");			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.VIDEO_ENDED, welcomeVideoFinished);			AppController.getInstance().playWelcomeVideo();		}				private function welcomeVideoFinished(e:Event = null):void{			log("* welcomeVideoFinished");			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.VIDEO_ENDED, welcomeVideoFinished);			playOpenBookAnim();		}		//TODO: remove these ???		private function checkSession():void{			incrementTotal(SbProgressBar.CHECK_SESSION_PROG_INDEX, 1);			log("* checkSession:");			//showLoader();			//AppController.getInstance().checkSession();			CoreEventDispatcher.getInstance().addEventListener(AppEvents.FINISH_INTRO, onCheckSession);			AppController.getInstance().startUserFlow();		}				private function onCheckSession(e:GenericDataEvent=null):void{			log("* onCheckSession:"+e.type);			incrementProgress(SbProgressBar.CHECK_SESSION_PROG_INDEX, 1);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.FINISH_INTRO, onCheckSession);			checkIntroDone();		}				private function checkIntroDone():void {			if (_introAnimFinished) {				if (SpeakaboosService.getInstance().savedStoryCount == 0) {					playWelcomeVideo();					_introAnim.gotoAndStop(_titleAnimDoneFrame);				} else {					TweenLite.delayedCall(0.1, playOpenBookAnim); // allow the complete prog bar to be seen				}			}		}				private function playOpenBookAnim(e:GenericDataEvent = null):void{			log("* playOpenBookAnim:"+ new Date().getTime() / 1000);			removeProgBar();			bookClosed.visible = false;						killIntroAnim();			_introAnim = new BookOpening();			_introAnim.x = 598;			_introAnim.y = 450;			_introAnim.addFrameScript(_introAnim.totalFrames - 1, showController);//			_introAnim.addEventListener(AppEvents.ANIM_FINISHED, showController);			addChild(_introAnim);		}								private function showController(e:* = null):void {			log("* showController milliseconds: "+ new Date().getTime() / 1000);			removeProgBar();			introFinished = true;			AppController.getInstance().startOpenBook();			//AppController.getInstance().startUserFlow();			AppController.getInstance().visible = true;			killIntroAnim();		}				private function killIntroAnim():void {			if (_introAnim) {				_introAnim.removeEventListener(MouseEvent.MOUSE_DOWN, animFinished);				_introAnim.gotoAndStop(1);				removeChild(_introAnim);				_introAnim = null;			}		}				private function onUpdateSinceLoaded(data:Object):void {			_updateAvailable = false;			if (data.status == "ok") {				_updateAvailable = ((int(data.categoriesUpdated) + int(data.storiesUpdated) + int(data.genericContentUpdated)) > 0);			}			if (_updateAvailable && _resetPending) reset();			log("onUpdateSinceLoaded _updateAvailable, _resetPending = "+_updateAvailable+", "+_resetPending );		}				private function onAppInForeground(event:Event=null):void {			CentralEventDispatcher.getInstance().dispatchEvent(new StoryEvent(StoryEvent.RETURN_FROM_BACKGROUND));			if (AppController.instantiated) {				var curTime:Number = new Date().getTime();				log("IPAD APP ACTIVATE in Foreground " + (_lastBackgroundTime < (curTime - MIN_IN_BACKGROUND_CHECK_TIME))+", "+(_lastBackgroundTime - (curTime - MIN_IN_BACKGROUND_CHECK_TIME)));				if (_lastBackgroundTime < (curTime - MIN_IN_BACKGROUND_CHECK_TIME)) {					_resetPending = false;					AppController.getInstance().firstOfflineModeChange = true;					var preloadDone = introFinished || !_progBar || (_progBar.progress >= 1);					log("IPAD APP ACTIVATE in Foreground "+_updateAvailable+","+_preloader+","+(PreloadService.lastUpdateTime - (curTime - MIN_UPDATE_CHECK_TIME))+", "+(!AppController.instantiated || AppController.getInstance()..appInteruptable()));						if (preloadDone && (!AppController.instantiated || AppController.getInstance().appInteruptable())) {						if (_updateAvailable && (PreloadService.lastUpdateTime < (curTime - MIN_UPDATE_CHECK_TIME))) {							_resetPending = true;						}						SpeakaboosService.getInstance().checkUdatedSince(onUpdateSinceLoaded);						// just do quick check to save for next time					}				}				AppController.getInstance().checkOnline();			}		}						private function onAppInBackground(event:Event=null):void{			CentralEventDispatcher.getInstance().dispatchEvent(new StoryEvent(StoryEvent.GO_TO_BACKGROUND));			_lastBackgroundTime = new Date().getTime();			log("* IPAD APP DEACTIVATE and in Background");					}				override public function destroy():void {			//TODO: finish destory			log("destroy");			_updateAvailable = false;			_resetPending = false;			introFinished = false;			removeListeners();			if (AppController.instantiated) {				AppController.getInstance().reset();			}			SpeakaboosService.destroySingleton();			SubscriptionService.destroySingleton();			LoginService.destroySingleton();			UserProfileImpl.destroySingleton();			StoreKitService.destroySingleton();			NetworkMonitor.destroySingleton();			BookView.destroySingleton();			bookOpen = null;			bookClosed = null;			bg = null;			main = null;			killIntroAnim();			if (_progBar) _progBar.destroy();			_progBar = null;			if (_preloader) _preloader.destroy();			_preloader = null;			CacheDataService.destoryStatic();			//			enterDebugger(); // for testing destory having removed all listeners properly before eventdispatcher is destroyed.			super.destroy();			CoreEventDispatcher.destroySingleton()		}	}}