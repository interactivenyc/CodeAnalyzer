package com.speakaboos.ipad.controller{	import com.speakaboos.core.settings.AppConfig;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.CoreEventDispatcher;	import com.speakaboos.ipad.events.DBEvents;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.events.LoginEvents;	import com.speakaboos.ipad.events.ModalEvents;	import com.speakaboos.ipad.events.NavEvents;	import com.speakaboos.ipad.events.SpeakaboosServiceEvents;	import com.speakaboos.ipad.events.SubscriptionEvents;	import com.speakaboos.ipad.models.data.ErrorStruct;	import com.speakaboos.ipad.models.data.ModalsInfo;	import com.speakaboos.ipad.models.data.Story;	import com.speakaboos.ipad.models.data.UserProfile;	import com.speakaboos.ipad.models.impl.UserProfileImpl;	import com.speakaboos.ipad.models.services.CacheDataService;	import com.speakaboos.ipad.models.services.FacebookService;	import com.speakaboos.ipad.models.services.LoginService;	import com.speakaboos.ipad.models.services.NetworkMonitor;	import com.speakaboos.ipad.models.services.SpeakaboosService;	import com.speakaboos.ipad.models.services.StoreKitService;	import com.speakaboos.ipad.utils.FileUtil;	import com.speakaboos.ipad.utils.HtmlTextUtil;	import com.speakaboos.ipad.utils.MovieClipUtils;	import com.speakaboos.ipad.utils.ObjectUtils;	import com.speakaboos.ipad.utils.Validation;	import com.speakaboos.ipad.view.BookView;	import com.speakaboos.ipad.view.CoreView;	import com.speakaboos.ipad.view.components.CoreMovieClip;	import com.speakaboos.ipad.view.holders.components.LogButton;	import com.speakaboos.mobile.ios.notifications.PushNotificationsController;	import com.speakaboos.story.controller.StoryController;	import com.speakaboos.story.events.CentralEventDispatcher;	import com.speakaboos.story.events.StoryEvent;	import com.speakaboos.story.utils.VideoPlayer;		import flash.debugger.enterDebugger;	import flash.desktop.NativeApplication;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TransformGestureEvent;	import flash.filesystem.File;	import flash.geom.Point;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.system.System;	import flash.ui.Multitouch;	import flash.ui.MultitouchInputMode;		import net.hires.debug.Stats;
		public class AppController extends CoreMovieClip	{		private static var _instance:AppController;		private static var initialized:Boolean = false;				private var _stageWidth:int = StartupController.WIDTH; 		private var _stageHeight:int = StartupController.HEIGHT; 				//Services		private var _speakaboosService:SpeakaboosService;				//Main Views		private var _bookViewContainer:MovieClip;		private var _storyController:StoryController;		private var _videoPlayer:VideoPlayer;				private var _loginViewContainer:MovieClip;		public var _loginViewController:CoreView;		private var _modalViewContainer:MovieClip;		public var modalController:ModalController; //Public so startupController can access if needed		private var _subscriptionController:SubscriptionController;		private var _pushNotificationsController:PushNotificationsController;		//		private var offlineMC:MovieClip;		private var modeBadgeMC:MovieClip;		public var bookGraphic:MovieClip;		public var logButton:LogButton;					private var _statsClip:Stats;				//State Variables		private static var _newSection:Boolean = true;		private static var _previousViewMode:String;		private static var _animating:Boolean = false;		private static var _firstOfflineModeChange:Boolean;				public static var firstTimeUser:Boolean;		public static var categoryPageInitialized:Boolean = false;		public static var inOfflineMode:Boolean;		public static var inRestrictedMode:Boolean;				private static var _viewMode:String = MODE_CATEGORIES;				public static const MODE_CATEGORIES:String = "MODE_CATEGORIES";		public static const MODE_STORIES:String = "MODE_STORIES";		public static const MODE_STORY:String = "MODE_STORY";				public static var LOADER_CONTEXT:LoaderContext;		public static const FREE_STORY_LIMIT:int = AppConfig.DEBUG_MODE ? 3 : 3; //var so we can change this for debugging		//LET'S REPLACE CATEGORYBACK BY USING THE NEWLY CREATED PREVIOUSVIEWMODE		private static var _categoryBack:Boolean = false;				//THIS SHOULD BE KEPT BY SPEAKABOOSSERVICE		private static var _currentStory:Story;		private var _inTrialMode:Boolean = false;		public static function get currentStory():Story {return _currentStory};										/*********************************************************************		 * GETTER/SETTERS		 *********************************************************************/				public function get storyController():StoryController {return _storyController}		public function set firstOfflineModeChange(val:Boolean):void{_firstOfflineModeChange = val};				public static function set newSection(newSection:Boolean):void{_newSection = newSection};		public static function get newSection():Boolean{return _newSection};				public static function set categoryBack(categoryBack:Boolean):void{_categoryBack = categoryBack};		public static function get categoryBack():Boolean{return _categoryBack};						public static function get animating():Boolean{return _animating};		public static function set animating(animating:Boolean):void{_animating = animating};				public static function get previousViewMode():String{return _previousViewMode};				public static function get viewMode():String{return _viewMode};		public static function set viewMode(viewMode:String):void{			_previousViewMode = _viewMode;			_viewMode = viewMode;		}						/*********************************************************************		 * APP CONTROLLER CONSTRUCTOR		 *********************************************************************/						public function AppController(enforcer:SingletonEnforcer){			log("constructor");						super();			if( enforcer == null ) throw new Error( "AppController is a singleton class and should only be instantiated via its static getInstance() method" );		}				public static function get instantiated():Boolean {return Boolean(_instance)};		public static function getInstance():AppController {			if( _instance == null ) {				_instance = new AppController( new SingletonEnforcer() );			}			_instance.init();			return _instance;		}				override protected function init():void {			if (!initialized) {				initialized = true;				log("AppController init");				super.init();				_firstOfflineModeChange = true;				MovieClipUtils.stageHeight = _stageHeight;				MovieClipUtils.stageWidth = _stageWidth;				Multitouch.inputMode = MultitouchInputMode.NONE;				LOADER_CONTEXT = new LoaderContext(false,ApplicationDomain.currentDomain,null); //avoids some security sandbox headaches that plague many users.								//			offlineMC = new OfflineModeMC();				//			offlineMC.visible = false;				//			MovieClipUtils.centerDisplayObject(offlineMC, new Point(13,0));				//			offlineMC.y = 0;				//			offlineMC.addEventListener(MouseEvent.MOUSE_DOWN, checkOnline);								modeBadgeMC = new RestrictedModeMC();				modeBadgeMC.visible = false;				MovieClipUtils.centerDisplayObject(modeBadgeMC, new Point(0,0));				modeBadgeMC.y = 0;				modeBadgeMC.addEventListener(MouseEvent.MOUSE_DOWN, onModeBadgeClicked);								if (AppConfig.DEBUG_MODE) {					initLog();				}								_loginViewContainer = new MovieClip();				_bookViewContainer = new MovieClip();				_modalViewContainer = new MovieClip();								_statsClip = new Stats(); //TODO: remove when removed from stage				if (!AppConfig.DEBUG_MODE) { 					addChild(_statsClip);				}				addChild(_loginViewContainer);				addChild(_bookViewContainer);				addChild(modeBadgeMC);				addChild(_modalViewContainer);								if (AppConfig.DEBUG_MODE) { 					addChild(_statsClip);				}				initControllers();				//prepVideo();				initServices();				_modalViewContainer.addChild(modalController.mc);			}		}				override protected function onAddedToStage(e:Event):void{			super.onAddedToStage(e);			log("onAddedToStage");			checkOnline();						drawBackground();			_newSection = true;			addEventListeners();					}				public function startOpenBook():void {			checkOnline();			BookView.getInstance().showCategories();			appStateUpdated();		}				override protected function onRemovedFromStage(e:Event):void{			super.onRemovedFromStage(e);			removeEventListeners();			resetViews();			_modalViewContainer.removeChild(modalController.mc);			if (_statsClip) removeChild(_statsClip);		}				private function initLog():void {			logButton = new LogButton(showLog);		}				private function addEventListeners():void{						stage.addEventListener(MouseEvent.MOUSE_DOWN, stageMouseDown);						//OTHER EVENTS			CoreEventDispatcher.getInstance().addEventListener(AppEvents.USER_READY, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.INIT_LOGIN, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.LOGOUT_USER, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.FORGOT_PASSWORD_SENT, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.FORGOT_PASSWORD_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(DBEvents.USER_ADDED_TO_DB, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_OPEN, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.MODAL_CLOSED_ALL, receiveEvent);						CoreEventDispatcher.getInstance().addEventListener(NavEvents.GO_HOME, receiveEvent);						//APPLICATION EVENTS			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHECK_ONLINE_STATE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHECK_RESTRICTED_MODE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHANGE_VIEW_MODE, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.NETWORK_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.APP_OFFLINE_MODE_CHANGE, onOfflineModeChange);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.SHOW_PREFERENCES, showPreferences);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.CHECK_FOR_UPDATES, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.PLAY_WELCOME_VIDEO, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.STORY_ASSETS_LOADED, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.NETWORK_STATUS, receiveEvent);						//SPEAKABOOS SERVICE EVENTS			CoreEventDispatcher.getInstance().addEventListener(SpeakaboosServiceEvents.LOAD_STORY, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(SpeakaboosServiceEvents.STORIES_LOADED, receiveEvent);						//SUBSCRIPTION SERVICE EVENTS			CoreEventDispatcher.getInstance().addEventListener(SubscriptionEvents.SUBSCRIBE_SUCCEEDED, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(SubscriptionEvents.SUBSCRIBE_FAILED, receiveEvent);						//GESTURE HANDLING - CENTRALIZED HERE			Multitouch.inputMode = MultitouchInputMode.GESTURE;			stage.addEventListener(TransformGestureEvent.GESTURE_SWIPE, onGestureEvent);						//STORY EVENTS FROM THE SPE			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.START_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.LOAD_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.EXIT_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.RETURN_TO_TITLE_SCREEN, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.STOP_STORY_LOAD, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.LOAD_RELATED_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.SERVICE_ERROR, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.DISPLAY_END_SCREEN, onStoryEvent);			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.END_FRAME_REACHED, onStoryEvent);			//			CentralEventDispatcher.getInstance().addEventListener(StoryEvent.STREAM_ERROR, onStoryEvent);					}				private function removeEventListeners():void{						stage.removeEventListener(MouseEvent.MOUSE_DOWN, stageMouseDown);						//OTHER EVENTS			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.USER_READY, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.INIT_LOGIN, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.LOGOUT_USER, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.FORGOT_PASSWORD_SENT, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.FORGOT_PASSWORD_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(DBEvents.USER_ADDED_TO_DB, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(NavEvents.GO_HOME, receiveEvent);						//APPLICATION EVENTS			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHECK_ONLINE_STATE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHECK_RESTRICTED_MODE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHANGE_VIEW_MODE, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.NETWORK_ERROR, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.APP_OFFLINE_MODE_CHANGE, onOfflineModeChange);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.SHOW_PREFERENCES, showPreferences);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.CHECK_FOR_UPDATES, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.PLAY_WELCOME_VIDEO, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.STORY_ASSETS_LOADED, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.NETWORK_STATUS, receiveEvent);						//SPEAKABOOS SERVICE EVENTS			CoreEventDispatcher.getInstance().removeEventListener(SpeakaboosServiceEvents.LOAD_STORY, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(SpeakaboosServiceEvents.STORIES_LOADED, receiveEvent);						//SUBSCRIPTION SERVICE EVENTS			CoreEventDispatcher.getInstance().removeEventListener(SubscriptionEvents.SUBSCRIBE_SUCCEEDED, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(SubscriptionEvents.SUBSCRIBE_FAILED, receiveEvent);						//GESTURE HANDLING - CENTRALIZED HERE			Multitouch.inputMode = MultitouchInputMode.GESTURE;			if (stage) stage.removeEventListener(TransformGestureEvent.GESTURE_SWIPE, onGestureEvent);						//STORY EVENTS FROM THE SPE			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.START_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.LOAD_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.EXIT_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.RETURN_TO_TITLE_SCREEN, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.STOP_STORY_LOAD, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.LOAD_RELATED_STORY, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.SERVICE_ERROR, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.DISPLAY_END_SCREEN, onStoryEvent);			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.END_FRAME_REACHED, onStoryEvent);//			CentralEventDispatcher.getInstance().removeEventListener(StoryEvent.STREAM_ERROR, onStoryEvent);					}				private function stageMouseDown(e:MouseEvent):void{			if (inOfflineMode == true) checkOnline();		}				private function prepVideo():void {			_videoPlayer = VideoPlayer.getInstance();			addChild(_videoPlayer);		}				public function playWelcomeVideo(e:Event = null):void{//			log("* PLAY_WELCOME_VIDEO");//			var file:File = new File(FileUtil.getLibraryDir("/data").url + "/video/welcome-video.mp4")//			//var file:File = new File(File.applicationDirectory.nativePath + "/data/video/welcome-video.mp4");//			var file:File = new File("./data/video/welcome-video.mp4");						log("* PLAY_WELCOME_VIDEO");			var file:File = FileUtil.getAppBundleSubPath("/data/video/welcome-video.mp4");			log("file.exists: "+file.exists);			if(!file.exists){				log("File does not exist.  calling endWelcomeVideo");				endWelcomeVideo();			}else{							log("File exists.  starting video playback");				if (!_videoPlayer || !contains(_videoPlayer)) prepVideo();							CentralEventDispatcher.getInstance().addEventListener(StoryEvent.VIDEO_ENDED, endWelcomeVideo);				_videoPlayer.playVideo(file.url);			}		}						/*********************************************************************		 * ONLINE AND RESTRICTED MODES		 *********************************************************************/						public function checkOnline(e:Event = null):Boolean {			log("* checkOnline NetworkMonitor.getInstance().isOnline: "+NetworkMonitor.getInstance().isOnline);						//FORCE OFFLINE			if (AppConfig.forceOfflineMode == true) {				updateOfflineMode(true);				return true;			}						if (NetworkMonitor.getInstance().isOnline) {				if (inOfflineMode) updateOfflineMode(false);				return true;			} else {				if (!inOfflineMode) {					updateOfflineMode(true);				}				return false;			}		}				private function onOfflineModeChange(e:GenericDataEvent):void {			log("onOfflineModeChange offline: "+e.data.offline);						if (AppConfig.forceOfflineMode == true){				updateOfflineMode(false);			}else{				updateOfflineMode(e.data.offline);							}								}				private function updateOfflineMode(pOffline:Boolean):void {			//log("updateOfflineMode offline: "+pOffline+", "+inOfflineMode+", "+_firstOfflineModeChange);			if (CacheDataService.preloadComplete) { // && (inOfflineMode != pOffline)) { 				var offlineChanged:Boolean = inOfflineMode !== pOffline;				if (pOffline && _firstOfflineModeChange) {					_firstOfflineModeChange = false;					offlineChanged = true;					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id: ModalsInfo.NEED_CONNECTION_ID}));				}				inOfflineMode = pOffline;				if (offlineChanged) {					appStateUpdated();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.CONNECTION_MODE_CHANGED));				}				log("* updateOfflineMode inOfflineMode: "+inOfflineMode);			}		}				public function updateRestrictedMode(restricted:Boolean, freeTrialer:Boolean = false):void {			log("* updateRestrictedMcVis restricted: "+restricted+", trialer:"+freeTrialer+", offline:"+inOfflineMode);			var updated:Boolean = false;			if (freeTrialer !== _inTrialMode) {				_inTrialMode = freeTrialer;				updated = true;			}			if (inRestrictedMode !== restricted) {				inRestrictedMode = restricted;				updated = true;			}			if (updated) {				appStateUpdated();				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.RESTRICTED_MODE_CHANGED, {restricted:restricted, freeTrialer:_inTrialMode}));			}		}		private function updateModeBadge():void {			checkUserHasFullAccess();			var txt:String;			//Set badge text based on sub expired or not			if (inOfflineMode) {				txt = "<p>You're Not<br>Connected</p>";			} else {				if (subscriptionHasExpired()) {					txt = "<p>Your Subscription<br>Has Expired</p>";				} else {					if (inRestrictedMode) {						txt = "<p>Keep Reading,<br>Join Today!</p>"					} else {						txt = "<p>Try Three<br>Stories Free!</p>"					}				}			}			HtmlTextUtil.setFieldText(modeBadgeMC.label, txt, HtmlTextUtil.BUTTON);			modeBadgeMC.visible = (inRestrictedMode || _inTrialMode || inOfflineMode) && (_viewMode !== MODE_STORY);		}				private function onModeBadgeClicked(e:MouseEvent):void {			if (inOfflineMode) {				checkOnline();			} else if (inRestrictedMode) {				showSubscribe();			}		}						private function initServices():void{			//log("initServices");			_speakaboosService = SpeakaboosService.getInstance();		}						public function startUserFlow():void{			log("*** startUserFlow()");			//DB creation and init handled in StartupController			showLoader();			UserProfileImpl.getInstance().getLastKnownUser(onGetLastUserProfile);		}				private function initControllers():void {			UserProfileImpl.getInstance();			modalController = new ModalController(this);			_subscriptionController = new SubscriptionController(this);			if (!_storyController) {				_storyController = new StoryController(_stageWidth, _stageHeight, AppConfig.DEBUG_MODE);			}			_pushNotificationsController = new PushNotificationsController();			if(!_pushNotificationsController.init()){				_pushNotificationsController.destroy();				_pushNotificationsController = null;						}		}						private function showLog(e:Event = null):void{			//log("showLog");						//NORMAL BEHAVIOR			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_LOG));				//			//TOGGLE OFFLINE//			AppConfig.forceOfflineMode = !AppConfig.forceOfflineMode;//			checkOnline();			//			//TOGGLE RESTRICTED//			checkRestricted();			//			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.PLAY_WELCOME_VIDEO));						//UserProfileImpl.getInstance().userProfile.email = null;			//			//BREAK FOR DEBUG//			breakMe();			//			//TRACE USER PROFILE//			log("UserProfileImpl:");//			log(ObjectUtils.getGenericObject(UserProfileImpl.getInstance()));		}				public function breakMe():void{			new MovieClip().breakme();		}				public static function appendLog(m:String):void {			ModalController.logMessage(m);		}				/**		 * This function gets called by DBService, after it has opened the local		 * database, and retrieved the stored userProfile		 **/ 				private function onGetLastUserProfile(u:UserProfile):void{				log("*** onGetLastUserProfile");			log(ObjectUtils.getGenericObject(u));						//if (e.data.userProfile == null){			if(u == null){				log("user not found in db");				firstTimeUser = true;				registerAnonymousUser();				//initLoginView();			}else{								log("email: " + u.email + ", session: " + u.session);								/**				 * If user has been found in DB, log them in automatically.				 * Note: FB authentication disabled below				 **/								//setUserProfile(e.data.userProfile);				setUserProfile(u);				if (inOfflineMode) { //TODO: something better when in offline mode					doSubscriptionFlow();				} else {					log("checking session");					checkSession();				}								/* code below removed, as there is no FB authentication in this build */				/*if(isFBUser()){					//fb user					//re-authenticate with fb					fbReAuthenticate();									}else{					//not an fb user					//check speakaboos server for valid session					log("checking session");					checkSession();				}				*/			}					}														/*********************************************************************		 * PAGE DISPLAY		 *********************************************************************/				public function initLoginView():void{			log("initLoginView");			resetLoginView();		}								private function resetViews():void{			//log("resetViews");			//BookView.getInstance().removeCurrentView();			if(this.contains(_bookViewContainer)){				_bookViewContainer.removeChild(BookView.getInstance().mc);			}			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));			//_globalNav.reset();			resetLoginView();		}				private function resetLoginView():void{			appStateUpdated();						if(_loginViewController){				log("resetting loginView");				if (_loginViewContainer.contains(_loginViewController)) {					_loginViewContainer.removeChild(_loginViewController);				}				var lvc:LoginViewController = _loginViewController as LoginViewController;				lvc.destroy();				lvc = null;				_loginViewController = null;			}						log("instantiating login view");			_loginViewController = new LoginViewController(this);			_loginViewContainer.addChild(_loginViewController);					}								private function drawBackground():void{			//log("drawBackground");						_bookViewContainer.addChild(BookView.getInstance().mc);						if (AppConfig.DEBUG_MODE == true){				if (!_modalViewContainer.contains(logButton.mc)) {					_modalViewContainer.addChild(logButton.mc);				}			}		}				private function endWelcomeVideo(e:StoryEvent=null):void{			log("* END WELCOME VIDEO");			var ced:CentralEventDispatcher = CentralEventDispatcher.getInstance();			if(ced.hasEventListener(StoryEvent.VIDEO_ENDED)){				ced.removeEventListener(StoryEvent.VIDEO_ENDED, endWelcomeVideo);			}						if (_videoPlayer!=null && contains(_videoPlayer)) {				log("removing video player");				removeChild(_videoPlayer);			}					}						/*********************************************************************		 * VIEW ACCESS		 *********************************************************************/				private function showNetworkErrorDialog():void{			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.NETWORK_ERROR_ID }));		}						protected function forceQuit(e:GenericDataEvent=null):void{			NativeApplication.nativeApplication.exit();		}						/*********************************************************************		 * EVENT HANDLING		 *********************************************************************/						private function onGestureEvent(e:TransformGestureEvent):void{			//log("onGestureEvent: target: "+e.target+", stageLoc: ("+e.stageX+","+e.stageY + ") localLoc: ("+e.localX+","+e.localY+")");			//log("ModalController.modalOpen(): "+ModalController.modalOpen());			//			if (_animating == true) return;//			if (_viewMode == MODE_STORY) return;//			if (modalController.modalOpen() == true) return;			if (appInteruptable()) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.ON_GESTURE, {gestureEvent:e}));			}		}				public function appInteruptable(ignoreAnimating:Boolean = false):Boolean {			return (ignoreAnimating || !_animating) && (_viewMode !== MODE_STORY) && modalController && !(modalController.modalOpen());		}				private function receiveEvent(e:GenericDataEvent):void{			log("* receiveEvent type:"+e.type);						var story:Story;			var i:int;						switch(e.type){								case AppEvents.NETWORK_ERROR:					if (StartupController.introFinished) {						if (NetworkMonitor.getInstance().isOnline) {							showNetworkErrorDialog();						} else {							updateOfflineMode(true);						}					} else {						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));					}					break;								//SPEAKABOOS SERVICE EVENTS						case SpeakaboosServiceEvents.STORIES_LOADED:					if (_speakaboosService.categoryHasSavedStories() || checkOnline()) {						_newSection = true;						BookView.getInstance().showStories();					}					break;								case SpeakaboosServiceEvents.LOAD_STORY:					_currentStory = e.data.story;					log("load story saved?", _currentStory.saved, _currentStory.slug);					var fullAccess:Boolean = checkUserHasFullAccess();//(_speakaboosService.savedStoryCount < FREE_STORY_LIMIT);					//					var fullAccess:Boolean = (_speakaboosService.savedStoryCount < storySaveLimit);					if (_currentStory.saved || (checkOnline() && fullAccess)) {						_newSection = true						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));						_currentStory.inOfflineMode = inOfflineMode;						BookView.getInstance().showStory(_currentStory);						modeBadgeMC.visible = false;					} else if (!fullAccess) {						showSubscribe();					}					break;								case AppEvents.LOGOUT_USER:					logOut();					break;												case LoginEvents.LOGOUT_ERROR:				case LoginEvents.USER_LOGGED_OUT:										/*					sent by loginService on log out from server					*/					/*						get another anonymous user to preserve session					*/										removeAppLogoutListeners();					registerAnonymousUser();															break;												case DBEvents.USER_ADDED_TO_DB:					doSubscriptionFlow();														break;													case LoginEvents.UPDATE_USER_SUCCEEDED:										removeUpdateUserAccountListeners();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.ALL_SET_ID, clearStack:true}));					appStateUpdated();															break;								case LoginEvents.UPDATE_USER_FAILED:									removeUpdateUserAccountListeners();										CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));					appStateUpdated();					var thisError:ErrorStruct = e.data.error as ErrorStruct;					if(thisError.code != 501){						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.COMPLETE_ACCOUNT_FAILED_ID, clearStack:true}));					}else{						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.USED_EMAIL_ID, clearStack:true}));					}										break;												case AppEvents.USER_READY:					userReady();					break;								case LoginEvents.INIT_LOGIN:					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));					initLoginView();					break;								case LoginEvents.FORGOT_PASSWORD_SENT:					hideLoader();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.PASSWORD_RESET_ID}));										break;												case LoginEvents.FORGOT_PASSWORD_ERROR:					hideLoader();					var err:ErrorStruct = e.data.error as ErrorStruct;					if(err.code == 502){						//user not found error						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.BAD_EMAIL_ID}));					}else{						//unknown error occurred						HtmlTextUtil.textSubstitutions = {message: "We were unable to reset your password.  Please try again later."};						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.ERROR_MISC_ID}));					}					 					break;											case AppEvents.LOGIN_SUCCESS:					onSessionValidated(e);					break;								case AppEvents.LOGIN_ERROR:						processLoginError(e);					break;				case AppEvents.MODAL_OPEN:						modeBadgeMC.visible = false;					break;				case AppEvents.MODAL_CLOSED_ALL:					appStateUpdated(); //TODO: Should not need this, but sometimes mode changes are not completed, or calls left hanging					break;								case SubscriptionEvents.SUBSCRIBE_SUCCEEDED:										log("*** Event: SUBSCRIBE_SUCCEEDED");										var jsonData:Object = e.data.messageData;					var u:UserProfile = getUserProfile();//new UserProfile();					u.initWithData(jsonData);					//update db					log("saving subscription status to db");					saveUserToDB();										//complete the transaction with iTunes					var trans:String = ObjectUtils.getSafeParameter(jsonData.response, "transaction");					//var trans:String = jsonData.response.transaction;					if(Validation.isPopulated(trans)){						StoreKitService.getInstance().finishManualTransaction(trans);						appStateUpdated();												CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));						if(!UserProfileImpl.getInstance().hasEmail()){							CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.COMPLETE_ACCOUNT_ID, clearStack:true}));						}						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_SUCCEEDED_ID}));										}else{						//unkown error: there's no transaction ID!						HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(u, trans)};						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));					}										break;												case SubscriptionEvents.SUBSCRIBE_FAILED:										var errorObj:Object = e.data.error as Object;					handleFailedSubscription(errorObj);						break;												case NavEvents.GO_HOME:					if (AppConfig.DEBUG_MODE) flash.system.System.gc(); 					break;				case AppEvents.CHANGE_VIEW_MODE:					log("*** Event: CHANGE_VIEW_MODE: "+e.data.viewMode);										if (_viewMode == MODE_STORY) {						if (e.data.viewMode == MODE_CATEGORIES){							// going from a story straight back to the homepage							BookView.getInstance().suppressPageFlips = true;						}					}					viewMode = e.data.viewMode;					updateModeBadge();					break;				case AppEvents.PLAY_WELCOME_VIDEO:					playWelcomeVideo();					break;				case AppEvents.CHECK_ONLINE_STATE:					checkOnline();					break;				case AppEvents.CHECK_RESTRICTED_MODE:					updateModeBadge();					break;				case AppEvents.STORY_ASSETS_LOADED:					checkUserHasFullAccess();					break;				case AppEvents.CHECK_FOR_UPDATES:					//CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.SHOW_HOME_SCREEN));										break;								case LoginEvents.ANONYMOUS_USER_LOGGED_IN:					log("*** Event: ANONYMOUS_USER_LOGGED_IN");					//CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.ANONYMOUS_USER_LOGGED_IN, receiveEvent);					var up:UserProfile = e.data.userProfile as UserProfile;					//UserProfileImpl.getInstance().userProfile = up;					setUserProfile(up);					log("set user data:" + getUserProfile().session);					addUserToDB();					//doSubscriptionFlow();					//			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SIGN_IN_ID, clearStack:true}));//					appStateUpdated();//					showPreferences();					break;			}					}				private function onStoryEvent(e:StoryEvent):void{			log("*** onStoryEvent: "+e.type)						switch (e.type){				case StoryEvent.LOAD_STORY:					break;				case StoryEvent.PLAY_LOADED_STORY:					break;				case StoryEvent.START_STORY:					break;				case StoryEvent.LOAD_RELATED_STORY:				case StoryEvent.RETURN_TO_TITLE_SCREEN:				case StoryEvent.DISPLAY_END_SCREEN:				case StoryEvent.EXIT_STORY:				case StoryEvent.STOP_STORY_LOAD:				case StoryEvent.END_FRAME_REACHED:					break;				case StoryEvent.SERVICE_ERROR:					break;			}		}								private function userReady():void{			//log("userReady");			appStateUpdated();			firstTimeUser = false;			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));			_newSection = true;			BookView.getInstance().showCategories();		}				/*********************************************************************		 * USER AND SUBSCRIPTION METHODS		 *********************************************************************/				public function checkSession():void{			addAppLoginListeners();			LoginService.getInstance().checkSession(getUserProfile());		}				public function completeAccount(newName:String, newPw:String):void{			var u:UserProfile = getUserProfile();			if(u){				showLoader();				LoginService.getInstance().updateUserAccount(u, newName, newPw);				addUpdateUserAccountListeners();			}					}						private function addAppLoginListeners():void{			CoreEventDispatcher.getInstance().addEventListener(AppEvents.LOGIN_SUCCESS, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(AppEvents.LOGIN_ERROR, receiveEvent);		}				private function removeAppLoginListeners():void{			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.LOGIN_SUCCESS, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(AppEvents.LOGIN_ERROR, receiveEvent);		}				private function addFbReAuthListeners():void{			//log("adding FB Re-Auth Listeners");			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.FB_LOGGED_IN, onFbReAuthenticated);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.FB_LOGIN_FAILED, onFbReauthenticationFailed);		}				private function removeFbReAuthListeners():void{			//log("removing FB Re-Auth Listeners");			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.FB_LOGGED_IN, onFbReAuthenticated);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.FB_LOGIN_FAILED, onFbReauthenticationFailed);		}						final private function addAppLogoutListeners():void{			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.USER_LOGGED_OUT, receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.LOGOUT_ERROR, receiveEvent);		}						final private function removeAppLogoutListeners():void{			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.USER_LOGGED_OUT, receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.LOGOUT_ERROR, receiveEvent);		}				final private function addUpdateUserAccountListeners():void{			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.UPDATE_USER_SUCCEEDED,receiveEvent);			CoreEventDispatcher.getInstance().addEventListener(LoginEvents.UPDATE_USER_FAILED,receiveEvent);		}				final private function removeUpdateUserAccountListeners():void{			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.UPDATE_USER_SUCCEEDED,receiveEvent);			CoreEventDispatcher.getInstance().removeEventListener(LoginEvents.UPDATE_USER_FAILED,receiveEvent);		}								private function fbReAuthenticate():void{			addFbReAuthListeners();			FacebookService.getInstance().reAuthenticate();		}				private function onFbReAuthenticated(e:*):void{			//called for returning users				removeFbReAuthListeners();						var userProfile:UserProfile;			userProfile = e.data.userProfile as UserProfile;						var u:UserProfile = getUserProfile();			u.fb_id = userProfile.fb_id;						//fb user is re-authenticated			//now check for speakaboos session			checkSession();					}								private function onFbReauthenticationFailed(e:*):void{			//could not reauth with fb			removeFbReAuthListeners();						//log("Facebook Re-authentication failed");			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.FACEBOOK_FAILED_ID}));		}								private function onSessionValidated(e:GenericDataEvent):void{			log("onSessionValidated");						/*				NOTE: 				This callback function is called by login, checksession, and createAnonymousUser from LoginService				Be sure to use addUserToDB, rather than saveUserToDB()				addUserToDB() dispatches events that are used downstream			*/						CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));			showLoader();			removeAppLoginListeners();			/*				add new user to db			*/			addUserToDB();			// TODO: Maybe we need to wait until the user add is complete before finishing? not sure, and not sure how			if (!StartupController.introFinished) {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));			}		}			public function doSubscriptionFlow():void{			log("*** doSubscriptionFlow StartupController.introFinished: "+StartupController.introFinished);			hideLoader();						/**************************************************************/			/*  DON'T KNOW WHY THIS LINE IS HERE.  COMMENTED OUT FOR NOW  */			/*************************************************************/			//if (StartupController.introFinished == false) return; //TODO: why is this needed??						/*			check user's subscription status.			Generate MessageDialog for certain states						Handle invalid sessions separately			*/			//hideLoader();						log("* doSubscriptionFlow");			var subStatus:String = checkSubscriptionStatus();			log("Subscription status: " + subStatus+", "+StartupController.introFinished);						var subCntrl:SubscriptionController = getSubscriptionController();			var event:GenericDataEvent = subCntrl.getDialogEventFromStatus(subStatus,_speakaboosService.savedStoryCount);			appStateUpdated();			if (event) {				log("dispatching event...");				//enterDebugger();				if (StartupController.introFinished) {					CoreEventDispatcher.getInstance().dispatchEvent(event);				} else {					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));				}			} else {								/*				these states don't get handled by getDialogFromStatus() above				handle them ourselves				*/				switch (subStatus) {					case UserProfileImpl.FREE_TRIAL_USER:					case UserProfileImpl.RETURNING_USER:						if (!StartupController.introFinished) {							CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));						}						break;										case UserProfileImpl.INVALID_SESSION:						//invalid session						//return to login screen					default:						//log("Default subscription behavior. Show login screen");						//return to login screen						doInvalidSession();										}							}					}						private function processLoginError(e:GenericDataEvent):void{			var loginError:ErrorStruct = e.data.error as ErrorStruct;			if(loginError.code == 402){				hideLoader();				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.BAD_SIGN_IN_ID}));			}			else{				doInvalidSession();			}		}						private function doInvalidSession():void{			//return to login screen			removeAppLoginListeners();						//log("User's session is invalid -> logging the user out");			logOut();					}												private function onAllowFullAccess():void{			userReady();		}				public function showPreferences():void {			if (viewMode === MODE_CATEGORIES) { 				appStateUpdated();				var profile:UserProfileImpl = UserProfileImpl.getInstance();				log("* showPreferences");				log("isSpeakaboosSubscriber: "+profile.isSpeakaboosSubscriber());				log("isITunesSubscriber: "+profile.isITunesSubscriber());				log("trialIsOver: "+profile.trialIsOver());				log("sub expired? "+subscriptionHasExpired());												// these are the modal IDs for the 4 prefs states from left to right in Stephen's onboarding-screens.pdf				//TRIALING_USER_ID TRIAL_OVER_ID SIGNED_IN_EMAIL_ID SIGNED_IN_OTHER_ID				//TODO: set modalId properly based on user state				//					var modalId:String = ModalsInfo.SUBSCRIBE_ID;				var modalId:String;// = ModalsInfo.SIGNED_IN_EMAIL_ID;				if (subscriptionHasExpired()) {					modalId = ModalsInfo.SIGNED_IN_SUB_EXPIRED_ID;				} else if (profile.isSpeakaboosSubscriber()) {					modalId = ModalsInfo.SIGNED_IN_EMAIL_ID;				} else if (profile.isITunesSubscriber()) {					if (profile.hasEmail()) {						modalId = ModalsInfo.SIGNED_IN_EMAIL_ID;					} else {						modalId = ModalsInfo.SIGNED_IN_OTHER_ID;					} 				} else if (profile.trialIsOver()) {					modalId = ModalsInfo.TRIAL_OVER_ID;				} else {					modalId = ModalsInfo.TRIALING_USER_ID;				}				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:modalId, clearStack:true}));			}		}						/*		subscription modal		*/				private function showSubscriptionExpiredBlocker():void{			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_EXPIRED_ID, clearStack:true}));		}				public function showSubscribe(e:Event = null):void{			//log("showSubscribe");			var modalId:String = (subscriptionHasExpired()) ? ModalsInfo.SUBSCRIPTION_EXPIRED_ID : ModalsInfo.TRIAL_OVER_BLOCKER_ID;			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:modalId, clearStack:true}));		}				public function doNotSubscribe():void{			//log("doNotSubscribe");			userReady();		}				public function startFreeTrial():void{						// TODO			// refactor to use result of startFreeTrial();			//put startFreeTrial() in SubscribeService			userReady();			var u:UserProfile = getUserProfile();			LoginService.getInstance().startFreeTrial(u);		}						final private function getSubscriptionErrorString(up:UserProfile, transId:String):String{			var msgStr:String = ( (Validation.isPopulated(up.email) ? " Account: " + up.email : "") + (Validation.isPopulated(up.user_id) ? " User ID: " + up.user_id : "") + (Validation.isPopulated(transId) ? " Transaction: " + transId : ""));			return msgStr;		}								final private function handleFailedSubscription(errorObj:Object):void{					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.HIDE_LOADER));						var up:UserProfile = ((errorObj.userProfile != null) ? errorObj.userProfile : null) as UserProfile;			var error:ErrorStruct = errorObj.error as ErrorStruct;			var transId:String = errorObj.transaction as String;						var finishTrans:Function = function():void{				if(Validation.isPopulated(transId)){					StoreKitService.getInstance().finishManualTransaction(transId);				}			};						log("handleFailedSubscription");			log("Error code: " + error.code);			log("Transaction: " + transId);			if(up)			{log("userProfile, id: " + up.user_id + ", email: "  + up.email);}			else			{log("userProfile: null");}					switch(error.code){								case 21000:				case 21002:				case 21003:				case 21004:				case 21007:				case 21008:				case 21020: //21020: Any other itunes verification error 					//subscription error returned by Apple					//finish the transaction					finishTrans();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_APP_STORE_FAILED_ID}));					break;								case 21005:					//apple server is down					//alert user, but keep subscription in queue					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_APP_STORE_DOWN_ID}));					break;								case 21006:					//subscription has expired					finishTrans();					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_EXPIRED_ID, clearStack:true}));					break;								case 501:				case 405:					/*					501 Missing session or receipt parameter; 					405 Invalid session; 					*/					HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(up, transId)};					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));						break;								case 21030:					//receipt is valid, but speakaboos error occurred					//same as default behavior				default:					//speakaboos related error					//apple validation succeeded, complete the transaction					finishTrans();					HtmlTextUtil.textSubstitutions = {message:getSubscriptionErrorString(up, transId)};					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.SHOW_MODAL, {id:ModalsInfo.SUBSCRIPTION_FAILED_ID}));								}						//update the database and notify the app			if(up){				setAndSaveUserProfile(up);				appStateUpdated();			}					}						/* 		UserProfile * User Account related methods		*/						final private function registerAnonymousUser():void {			addAppLoginListeners();			LoginService.getInstance().registerAnonymousUser();		}				public function getUserProfile():UserProfile{			return UserProfileImpl.getInstance().userProfile;		}				public function setUserProfile(u:UserProfile):void{			UserProfileImpl.getInstance().userProfile = u;		}				public function checkSubscriptionStatus():String{			//convenience function			return UserProfileImpl.getInstance().getSubscriptionStatus();			}				public function isFBUser():Boolean{			return UserProfileImpl.getInstance().isFBUser();		}				public function subscriptionHasExpired():Boolean{			return UserProfileImpl.getInstance().subscriptionHasExpired();		}						public function clearSession():void{			UserProfileImpl.getInstance().clearSession();				}						public function addUserToDB():void{			/*				Insert a new user into the DB				Dispatches USER_ADDED_TO_DB event			*/			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(DBEvents.ADD_USER_TO_DB, {userProfile:getUserProfile()}));		}						public function saveUserToDB():void{			UserProfileImpl.getInstance().saveUser();		}				public function setAndSaveUserProfile(u:UserProfile):void{			setUserProfile(u);			saveUserToDB();		}				public function logIn(u:UserProfile):void{			showLoader();			addAppLoginListeners();			LoginService.getInstance().login(u);		}				public function logOut():void{			//clear the user from the database and present the login screen			CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(ModalEvents.CLOSE_ALL_MODALS));			var u:UserProfile = getUserProfile();			if (u == null){return};						//clear userProfile data and delete all db users 			var s:String = u.session;			FacebookService.getInstance().fbLogout();			UserProfileImpl.getInstance().clearAndFlushData();						addAppLogoutListeners();			LoginService.getInstance().logOut(s);			if (StartupController.introFinished) {				appStateUpdated();			} else {				CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.FINISH_INTRO));			}					}						/* user story state */		public function checkUserHasFullAccess():Boolean{			return UserProfileImpl.getInstance().userHasFullAccess(freeStoryLimitReached());		}						public function freeStoryLimitReached():Boolean{			if (_speakaboosService) {				return (_speakaboosService.savedStoryCount >= FREE_STORY_LIMIT);			} else {				return true;			}		}								/* accessors */		public function getSubscriptionController():SubscriptionController{			return _subscriptionController;		}								private function appStateUpdated():void {			if (StartupController.introFinished) { 				if (_viewMode !== MODE_STORY) { //don't bother updating state when in MODE_STORY - should not happen anyway... 					HtmlTextUtil.textSubstitutions = textSubstitutionObj;					var u:UserProfile = getUserProfile();					if (u && (u.subscription_state === UserProfileImpl.SUB_STATE_ACTIVE)) {						//if(){						//FREE_STORY_LIMIT = int.MAX_VALUE;					} else {						//storySaveLimit = FREE_STORY_LIMIT;					}					CoreEventDispatcher.getInstance().dispatchEvent(new GenericDataEvent(AppEvents.USER_DATA_UPDATED));				} else {					log("*** error: appStateUpdated called when in story mode");				}				updateModeBadge();			}		}				/* removed "getTextSubstitutions" to avoid confusion		This just sets up a object map for the properties to be replaced in text, using the same values as were in getTextSubstitutions		HtmlTextUtil uses this mapping to do the actual substitutions, this allows on the fly replacing and updating 		of map elements, setting the story name in the map before the dialog is shown for deleting a story.		*/		public function get textSubstitutionObj():Object {			log("get textSubstitutionObj()");						var result:Object = {				"version_num": AppConfig.APP_VERSION,					"cr_year": AppConfig.copyrightYear,					"subscriberType": "iPad"			};			var usrPrf:UserProfile = getUserProfile();			var strEmpty:String = "";			var str:String;			log("got email address from profile: " + usrPrf.email);			str = (usrPrf) ? usrPrf.email : strEmpty;//'noProfile@example.com';			str = (str == null) ? strEmpty : str;//'noEmail@example.com' : strEmail; 			log("email str: '" + str + "'" + ", sub state: " + usrPrf.subscription_state);			if (str == "" && UserProfileImpl.getInstance().isSubscriber()) 			{				log("setting email to 'iPad Subscriber' for display purposes");				str = "iPad Subscriber";			}			result["email"] = str;						str = (usrPrf) ? usrPrf.subscription_type : strEmpty;//':userProfile N/A:';			str = (str == null) ? strEmpty : str;//':subscriber type N/A:' : strSubType;			str = (str == 'itunes') ? "iPad" : str;			result["subscriber_type"] = str;						result["subscription_time"] = "";//usrPrf.getDaysLeft();//"30 days"; //TODO:  replace with real data						result["renew_date"] = usrPrf.getExpirationDate();						result["spe_version"] = StoryController.VERSION;			result["app_services"] = AppConfig.APP_SERVICES_STAGE;			result["app_release_type"] = AppConfig.APP_RELEASE_TYPE;									return result;		}				override public function destroy():void {			reset();			_instance = null;		}				public function reset():void {			log("AppController reset");			categoryPageInitialized = false;			_currentStory = null;			_viewMode = MODE_CATEGORIES;			_previousViewMode = null;			_newSection = true;			_categoryBack = false;			_animating = false;			//storySaveLimit = FREE_STORY_LIMIT;			inOfflineMode = false;						removeEventListeners();			firstTimeUser = true;			_currentStory = null;			_statsClip = null;			if (logButton && _modalViewContainer.contains(logButton.mc)) {				_modalViewContainer.removeChild(logButton.mc);				logButton.destroy();			}			logButton = null;			if (_storyController) _storyController.reset();			if (modalController) modalController.destroy();			if (_subscriptionController) _subscriptionController.destroy();			if (_pushNotificationsController) _pushNotificationsController.destroy();			modalController = null			_subscriptionController = null;			_pushNotificationsController = null;			_speakaboosService = null;						super.destroy();			removeChildren();			initialized = false;		}						/*********************************************************************		 * DEPRECATED VIDEO FUNCTIONS		 *********************************************************************/				//		private function initVideo():void{//			log("initVideo");//			//			_bookViewContainer.visible = false;//			_modalViewContainer.visible = false;//			_loginViewContainer.visible = false;//			//			_videoPlayer = new VideoPlayer(stage.width, 675);//			_videoPlayer.addEventListener(MouseEvent.MOUSE_DOWN, stopVideo);//			_videoPlayer.y = 112;//			//			addChild(_videoPlayer);//			_videoPlayer.addEventListener(VideoPlayer.VIDEO_FINISHED, introVideoFinished);//			_videoPlayer.addEventListener(VideoPlayer.PLAYER_READY, playWelcomeVideo);//		}//		//		private function playWelcomeVideo(e:Event):void{//			_videoPlayer.removeEventListener(VideoPlayer.PLAYER_READY, playWelcomeVideo);//			_videoPlayer.playVideo(FileUtil.getLibraryDir("/content").url + "/video/welcome-video.mp4");//		}//		//		private function stopVideo(e:MouseEvent = null):void{//			_videoPlayer.removeEventListener(MouseEvent.MOUSE_DOWN, stopVideo);//			_videoPlayer.stopVideo();//			introVideoFinished();//			//		}//		//		//		private function introVideoFinished(e:Event=null):void{//			//log("introVideoFinished");//			//			_videoPlayer.removeEventListener(VideoPlayer.VIDEO_FINISHED, introVideoFinished);//			//			_bookViewContainer.visible = true;//			_modalViewContainer.visible = true;//			_loginViewContainer.visible = true;//			//			removeChild(_videoPlayer);//		}			}}class SingletonEnforcer {	public function SingletonEnforcer():void {}}