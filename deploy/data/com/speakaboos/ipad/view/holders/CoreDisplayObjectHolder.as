package com.speakaboos.ipad.view.holders {		import com.speakaboos.ipad.CoreEventUser;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.models.data.HolderChildInfo;	import com.speakaboos.ipad.models.data.HolderChildParams;	import com.speakaboos.ipad.view.holders.components.CoreButton;	import com.speakaboos.ipad.utils.ObjectUtils;		import flash.debugger.enterDebugger;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.MovieClip;	import flash.display.Stage;	import flash.events.Event;	/**	 * @author Hudson	 * 	 * The intention of this class is to make using Flash Library instances	 *  simpler without having to extend them directly. To that end, this has 	 *  several convenience methods and getter/setters that allow this class to	 *  be treated as if it is actually an extention of the contained library	 *  item for simple cases. E.g.: you can set or get the x or y value of this 	 *  class, and it will be the same as setting the x, y of the held displayObject 	 *  For more complex or just rarer actions, you have access to "view" which is 	 *  the held displayObject instance. This can be used with any displayObject type,	 *  like textField, which does not extend movieClip. Use the CoreMovieClipHolder	 *  if the held instance extends movieClip.	 */	public class CoreDisplayObjectHolder extends CoreEventUser 	{		public var id:String;		protected static const DEFAULT_NAME:String = "DEFAULT_NAME";		public var parentHolder:CoreDisplayObjectHolder;		public var view:DisplayObject;				private var _childInfoLookUp: Object;		protected function get childInfoLookUp():Object {			return _childInfoLookUp;		}				public function get stage():Stage {			return view.stage;		}		public function get x():Number {			return view.x;		}		public function set x(val:Number):void {			view.x = val;		}		public function get y():Number {			return view.y;		}		public function set y(val:Number):void {			view.y = val;		}		public function get name():String {			return view.name;		}		public function set name(val:String):void {			view.name = val;		}		public function get width():Number {			return view.width;		}		public function set width(val:Number):void {			view.width = val;		}		public function get height():Number {			return view.height;		}		public function set height(val:Number):void {			view.height = val;		}		public function get alpha():Number {			return view.alpha;		}		public function set alpha(val:Number):void {			view.alpha = val;		}		public function get visible():Boolean {			return view.visible;		}		public function set visible(val:Boolean):void {			view.visible = val;		}				public function CoreDisplayObjectHolder(_view:DisplayObject) {			super();			view = _view;			init();		}		private function init():void {			_childInfoLookUp = {};			if (stage) {				addEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage,false,0,true);			} else {				addEventListener(Event.ADDED_TO_STAGE, onAddedToStage,false,0,true);			}		}				/**		 * Sets up children of the held displayObject, wrapping them in their own holder class if 		 *  that is in the params, otherwise using the bare displayObject. A function or event can		 *  also be passed in the params to be executed or dispatched when the item is clicked. 		 *  It also sets any public variables in this class if they have the same name as passed in 		 *  the params list.		 * 		 * This has to be called before this is added to the diplay list. It can be called by each 		 *  class in the ancestor chain to add more children as needed.		 * 		 * @param children list of params for children of the contained displayObject 		 */		protected function setupChildren(childParamList:Vector.<HolderChildParams>):void {			var childName:String;			var childInfo:Object			var holder:CoreDisplayObjectHolder;			var child:DisplayObject;			var childParams:HolderChildParams;			var i:int;			for (i=0; i<childParamList.length;i++) {				holder = null;				childParams = childParamList[i];				childName = childParams.name;				if (view is DisplayObjectContainer) {					child = (view as DisplayObjectContainer).getChildByName( childName);				}				if (childParams.clss) {					if (child) {						holder = new childParams.clss(child);					} else {						holder = new childParams.clss();					}					if (childParams.info) holder.setInfo(childParams.info);					holder.parentHolder = this;				}				if (this.hasOwnProperty(childName)) {					this[childName] = holder || child;				}				if (childName.indexOf("instance") == 0) {					log("add child without name ");					log(childParams.toString());					log(view, view.name);				}				setChildInfoLookup( childName, new HolderChildInfo(holder, childParams.clickFunc, childParams.clickEvent, child));				childParamList[i].reset();			}		}		public function setInfo(info:Object):void {			//Override if used		}		public function getData():Object {			//Override if used			return null;		}		protected function setChildInfoLookup( name:String, holderChildInfo:HolderChildInfo):void {//			log("setChildInfoLookup "+name);			//log(holderChildInfo);			clearChildInfoLookup( name);			if (holderChildInfo) _childInfoLookUp[name] = holderChildInfo;			else throw new Error("setChildInfoLookup with null info object"); //TODO: might want to remove this for release		}		protected function clearChildInfoLookup( name:String):void {			var ci:HolderChildInfo = _childInfoLookUp[name];			if (ci) ci.reset();			_childInfoLookUp[name] = null;		}		protected function removeAllChildHolders():void {			var nm:String;			for (nm in _childInfoLookUp) {				var hci:HolderChildInfo = _childInfoLookUp[nm] as HolderChildInfo;				if (hci) {					var h:CoreDisplayObjectHolder = (_childInfoLookUp[nm] as HolderChildInfo).holder;					if (h) h.destroy();					_childInfoLookUp[nm].reset();				} else {					//flash.debugger.enterDebugger();					log("removeAllChildHolders "+nm+" had null holder info");				}				delete _childInfoLookUp[nm];			}		}		protected function callAllChildHolders(funcName:String, args:Array = null):void {//			log("callAllChildHolders "+funcName);			var nm:String;			for (nm in _childInfoLookUp) {				var hci:HolderChildInfo = _childInfoLookUp[nm] as HolderChildInfo;				if (hci) {					var h:CoreDisplayObjectHolder = hci.holder;					var argLen:int = (args) ? args.length : 0;					if (h) {						var func:Function = h[funcName];//						log("callAllChildHolders "+funcName, h.id, func, argLen, func.length);						if ((typeof func === "function") && (argLen <= func.length)) {							if (argLen) {								func.apply(h, args);							} else {								func();							}						} else {							log("*** ERROR: callAllChildHolders called with bad function name '"+funcName+"', args:["+args+"], func "+func);						}					}				}			}		}		/**		 * 		 * @param child the displayObject or name of the displayObject for which you 		 *  want to get the holder class instance.		 * @return the class instance that "holds" the given child		 * 		 */				public function getHolderFromChild(child:*):CoreDisplayObjectHolder {			if (child is DisplayObject) child = child.name;			return (_childInfoLookUp[child]) ? _childInfoLookUp[child].holder : null;		}		/**		 * This is automatically called when an item is clicked, checking each child 		 *  to find the one clicked and executing its function or dispatching its event		 * 		 * @param e custom "event" object, does not inherit from Flash events		 * 		 */				private function onChildClick(e:GenericDataEvent):void{//			log("onChildClick");			var holder:CoreButton = e.data.button;			if (!holder) {				log("onChildClick called with bad event "+e.type);				log(e);				return;			}			var child:MovieClip = holder.mc;//			log("onChildClick core "+child.name+", "+view.name);			if (child && child.parent == view) { //does button belong to this holder?				var info:Object = _childInfoLookUp[child.name];				if (!info) {					info = _childInfoLookUp[DEFAULT_NAME];				}				if (info) {					if (info.clickFunc) {						if (info.clickFunc.length) {							info.clickFunc(child);						} else {							info.clickFunc();						}					} else if (info.clickEvent) {						_eventDispatcher.dispatchEvent(info.clickEvent);					} else {						//if no click action set, then do nothing					}				} 			}		}		public function grandchildClicked(holder:CoreDisplayObjectHolder, child:DisplayObject):void {			// to be overridden		}		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true):void {			if (!view) return;			view.addEventListener(type, listener, useCapture, priority, useWeakReference);		}		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false):void {			if (!view) return;			view.removeEventListener(type, listener, useCapture);		}		public function onAddedToStage(e:Event = null):void {			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			addEventListener( Event.REMOVED_FROM_STAGE, onRemovedFromStage,false,0,true);			if (_eventDispatcher) {				_eventDispatcher.addEventListener(AppEvents.NEW_BUTTON_CLICK, onChildClick);			} else {				throw new Error("child added to stage with null eventDispatcher");			}//			callAllChildHolders("onAddedToStage");		}		public function onRemovedFromStage(e:Event = null):void{			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);          			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			if (_eventDispatcher) {				_eventDispatcher.removeEventListener(AppEvents.NEW_BUTTON_CLICK, onChildClick);			} else {				throw new Error("child removed from stage with null eventDispatcher");			}//			callAllChildHolders("onRemovedFromStage");		}				override public function destroy():void {			removeEventListener(Event.REMOVED_FROM_STAGE, onRemovedFromStage);						removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			if (_eventDispatcher) _eventDispatcher.removeEventListener(AppEvents.NEW_BUTTON_CLICK, onChildClick);			view = null;			//TODO: implement a pool for the holderInfo objects and return them to the pool here?			removeAllChildHolders();			for (var nm:String in _childInfoLookUp) { //TODO: remove this, just for diagnostic				throw new Error("removeAllChildHolders failed");			}			_childInfoLookUp = null;			super.destroy();		}	}}