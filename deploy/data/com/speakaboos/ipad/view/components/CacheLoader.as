package com.speakaboos.ipad.view.components{		import com.speakaboos.ipad.controller.AppController;	import com.speakaboos.ipad.events.CoreEventDispatcher;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.models.data.FileUrlInfo;	import com.speakaboos.ipad.utils.FileUtil;	import com.speakaboos.ipad.utils.debug.Logger;	import com.speakaboos.story.utils.AudioPlayer;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Loader;	import flash.display.PixelSnapping;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.TimerEvent;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.system.LoaderContext;	import flash.utils.ByteArray;	import flash.utils.Timer;			/**	 * This class will cache loaded DisplayObjects to the IOS Application Storage Directory	 * If a request is made for a cached item it will return it, rather than loading	 * it again.	 * 	 * This class will need rules for when to purge the cached items.	 * 	 * 	 * should not need the localDirectoryListing or _localDirectory as instance variables... although might want to have a directory static var for each of the bundled dir and cache dir instead of two functions	 * need to add both the bundle files and the saved files for each directory path passed in	 * need to use a different technique for saving the updated/unbundled media files encountered - think could just use one or two file streams to load and then to save... should be able to just do this on a generic file so mp3s will work	 * 	 * FileUtil.getCacheDir();	 **/		public class CacheLoader extends Loader	{		public static const MEDIA_PRELOADED:String = "MEDIA_PRELOADED";		public static const MEDIA_LOAD_ERROR:String = "MEDIA_LOAD_ERROR";		private static var _bundleDir:File;		private static var _cacheDir:File;		private static const FILE_SUBDIR:String = "/content";		public static const DATA_FOLDER:String = "/data";		public static var firstTimeLaunched:Boolean = false;		private static var _filePathCache:Object;		private static var _resourceMap:Object;		private static var _classInitted:Boolean = false;				private var _urlLoader:URLLoader;		private var _urlRequest:URLRequest;		private var _eventDispatcher:CoreEventDispatcher;		private static var _defaultContext:LoaderContext;		private var _content:DisplayObject;		private var _callbackTimer:Timer;				override public function get content():DisplayObject {			if (_content) return _content;			else return super.content;		}				public function CacheLoader() {			super();			init();		}				protected static function classInit():void {			_classInitted = true;						_filePathCache = {};			_cacheDir = FileUtil.getCacheDir(true, FILE_SUBDIR);			Logger.log("user dir "+_cacheDir.url);			_bundleDir = FileUtil.getLibraryDir(FILE_SUBDIR);			Logger.log("application bundle dir "+_bundleDir.url);			_defaultContext = AppController.LOADER_CONTEXT;		}				private function init():void		{			if (!_classInitted) classInit();			_callbackTimer = new Timer(1, 1);			_urlRequest = new URLRequest();			_eventDispatcher = CoreEventDispatcher.getInstance();			_urlLoader = new URLLoader();			_urlLoader.dataFormat = URLLoaderDataFormat.BINARY;			_urlLoader.addEventListener(Event.COMPLETE, onRawDataLoaded,false,0,true);			_urlLoader.addEventListener(IOErrorEvent.IO_ERROR, onMediaError,false,0,true);			_urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onMediaError,false,0,true);			//			contentLoaderInfo.addEventListener(Event.COMPLETE, onLoaded);			addEventListener(IOErrorEvent.IO_ERROR, onIOError,false,0,true);			contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError,false,0,true);			addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError,false,0,true);					}				protected function onRawDataLoaded(event:Event):void		{			//			log("onRawDataLoaded "+_urlRequest.url);			saveToCache( _urlRequest.url, _urlLoader.data);			_eventDispatcher.dispatchEvent(new GenericDataEvent(MEDIA_PRELOADED));//maybe this should not be called until save is done... or is it		}				private static function getFileCache(path:String, checkLocal:Boolean = true):Object {			var fileCache:Object = _filePathCache[path];			if (!fileCache) {				fileCache = {fileLookup:[], fileInfoArray:[], localAdded:false};				_filePathCache[path] = fileCache;			}			if (checkLocal && !fileCache.localAdded) {				var dir:File;				var dirListing:Array;				dir = _bundleDir.resolvePath(path);				if (dir.exists) {					dirListing = dir.getDirectoryListing();					addFilesFromDirectoryListing( fileCache, dirListing, FileUrlInfo.LOC_BUNDLE);				} else {					//Logger.log("***** Error bundle directory DNE:"+dir.url); // not really an error				}				dir = _cacheDir.resolvePath(path);				if (!dir.exists) dir.createDirectory();				dirListing = dir.getDirectoryListing();				addFilesFromDirectoryListing( fileCache, dirListing, FileUrlInfo.LOC_APP_STORAGE); // any files already cached in local storage should override ones in app bundle				fileCache.localAdded = true;			}			return fileCache;		}				private static function addFilesFromDirectoryListing(fileCache:Object, dirListing:Array, loc:String):void {			var fileInfo:FileUrlInfo;			var url:String;			var i:int, j:int;			for (i = 0; i < dirListing.length; i++) {				url = dirListing[i].url;				fileInfo = new FileUrlInfo(url, loc);				addFileInfoToCache(fileInfo, fileCache);			}		}				private static function addFileInfoToCache(fileInfo:FileUrlInfo, fileCache:Object = null, checkLocal = true):Boolean {			var replaced:Boolean = false;			var j:int;			if (fileInfo.valid) {				if (!fileCache) fileCache = getFileCache(fileInfo.path, checkLocal);				j = fileCache.fileLookup.indexOf(fileInfo.key);				if (j < 0) {					fileCache.fileLookup.push( fileInfo.key);					fileCache.fileInfoArray.push(fileInfo);				} else if (fileInfo.fullName != fileCache.fileInfoArray[j].fullName) {					fileCache.fileInfoArray[j] = fileInfo; //if already there but older, then replace					replaced = true;				}				//				Logger.log("addFileInfoToCache "+j+", "+replaced+", "+fileInfo.location+", "+fileInfo.path+fileInfo.fullName);			}			return replaced;		}				public function isMediaLocal(url:String):Boolean {			var results:Boolean;			var fileInfo:FileUrlInfo = new FileUrlInfo(url);			results = fileInfo.valid;			if (results) {				var fileCache:Object = getFileCache(fileInfo.path);				var j:int = fileCache.fileLookup.indexOf(fileInfo.key);				//				Logger.log("isMediaLocal "+j+", "+fileInfo.key+", "+fileInfo.fullName+", "+ (j<0?"":fileCache.fileInfoArray[j].location+", "+(fileInfo.fullName == fileCache.fileInfoArray[j].fullName)));				results = (j >= 0 && (fileInfo.fullName == fileCache.fileInfoArray[j].fullName));			} else {				Logger.log("isMediaLocal::ERROR invalid URL "+url);			}			return results;		}				public function preloadMedia(url:String):void {			if (isMediaLocal(url)) {				_eventDispatcher.dispatchEvent(new GenericDataEvent(MEDIA_PRELOADED), 1);			} else {				_urlRequest.url = url;				_urlLoader.load(_urlRequest);			}		}				public static function getCachedURL(url:String):String { 			var newUrl:String = url;			var fileInfo:FileUrlInfo = new FileUrlInfo(url);			//			Logger.log("getURLResource "+url+", "+fileInfo.valid+", "+"loc="+fileInfo.location+", "+fileInfo.path+fileInfo.fullName);			if (fileInfo.valid) {				var fileCache:Object = getFileCache(fileInfo.path);				var j:int = fileCache.fileLookup.indexOf(fileInfo.key);				if (j < 0) {					Logger.log("getURLResource not found in local cache! "+url);					newUrl = url;					// file not in local cache, should not happen				} else {					fileInfo = fileCache.fileInfoArray[j];					//Logger.log("getURLResource lu loc="+fileInfo.location+", "+fileInfo.path+fileInfo.fullName);					switch (fileInfo.location) {						case FileUrlInfo.LOC_APP_STORAGE:							newUrl = _cacheDir.resolvePath( fileInfo.path+fileInfo.fullName).url;							break;						case FileUrlInfo.LOC_BUNDLE:							newUrl = _bundleDir.resolvePath( fileInfo.path+fileInfo.fullName).url;							break;						case FileUrlInfo.LOC_WEB:							// not tested							break;						case FileUrlInfo.LOC_INTERNAL:							newUrl = fileInfo.linkage;							//for internal, the url is the linkage ID, which we just pass back firetly and the caller manages handling it							break;					}				}			}						//Logger.log("getCachedURL: "+url);			//Logger.log("newUrl: "+newUrl);						return newUrl;		}				public function loadUrl(url:String):void {			_content = null;			url = getCachedURL(url);			if (url) {				if (url.indexOf("/") < 0) {					var bmpdataClass:Class = _resourceMap[url] as Class;					var bd:BitmapData = new bmpdataClass() as BitmapData;					_content = new Bitmap( bd, PixelSnapping.AUTO, true);					_callbackTimer.addEventListener(TimerEvent.TIMER_COMPLETE, loadUrlComplete);					_callbackTimer.start();					//					log("loadUrl internal:"+url+", "+bd+", "+bmpdataClass+", ("+_content.width+", "+_content.height+"), "+_content);				} else {					//					log("loadUrl external:"+url);					_urlRequest.url = url;					load(_urlRequest);				}			} else {				_callbackTimer.addEventListener(TimerEvent.TIMER_COMPLETE, loadUrlComplete);				_callbackTimer.start();			}		}				private function loadUrlComplete(e:TimerEvent):void {			//			_callbackTimer.stop();			_callbackTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, loadUrlComplete);			dispatchEvent(new Event(Event.COMPLETE));		}				private function loadUrlInvalid(e:TimerEvent):void {			_callbackTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, loadUrlInvalid);			dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, "url not valid"));		}				public static function playAudioFromCachedUrl(url:String):Boolean {			url = getCachedURL(url);			var result:Boolean = Boolean(url);			if (result) {				if (url.indexOf("/") < 0) {					AudioPlayer.getInstance().playInternalSound(url);				} else {					AudioPlayer.getInstance().playExternalSound(url);				}			}			return result;		}				override public function load(request:URLRequest, context:LoaderContext=null):void{			_content = null;			_urlRequest = request;			if (!context) context = _defaultContext;			super.load(_urlRequest, context);		}				//		protected function onLoaded(e:Event):void{		//			if (contentLoaderInfo.contentType.indexOf("image") > -1){ //TODO: is this doing anything?		//				var smoothBitmap:Bitmap = Bitmap(content);		//				smoothBitmap.smoothing = true;		//				//Bitmap(content).rotationZ = 0; //force smoothing		//			}		//		}		/* loads a file from the local cache using a web url		* @param url - web url for asset		* @param forceDir - 0: try app storage, if not there, try bundle		*					1: only try app storage		*					2: only try bunlde storage		*/		public function loadFromCache(url:String, forceDir:int = 0):ByteArray { 			var result:ByteArray = null;			var file:File;			var fileInfo:FileUrlInfo = new FileUrlInfo(url);			if (forceDir !== 1) file = _cacheDir.resolvePath(fileInfo.path).resolvePath(fileInfo.fullName);			if ((forceDir !== 2) && (!file || !file.exists)) {				file = _bundleDir.resolvePath(fileInfo.path).resolvePath(fileInfo.fullName);			}			if (file.exists) {				result = new ByteArray();				var fs:FileStream = new FileStream();				fs.open(file, FileMode.READ);				fs.readBytes(result);				fs.close();			}			return result;		}				public function saveToCache(url:String, bytes:ByteArray):void { //TODO: also delete file this is replacing, if any			//			log("saveToCache url:"+url);			var fs:FileStream = new FileStream();			var file:File;			var fileInfo:FileUrlInfo = new FileUrlInfo(url, FileUrlInfo.LOC_APP_STORAGE);			file = _cacheDir.resolvePath(fileInfo.path);			if (!file.exists) file.createDirectory();			file = file.resolvePath(fileInfo.fullName);			//			log("saveToCache file url:"+file.url);			fs = new FileStream();			fs.open(file, FileMode.WRITE);			fs.writeBytes(bytes);			fs.close();			addFileInfoToCache(fileInfo);			//TODO: listen for progress update events? would make progress bar smoother		}				protected function onIOError(e:IOErrorEvent):void{			log("onIOError");			log(e.text);		}				protected function onSecurityError(e:SecurityErrorEvent):void{			log("onSecurityError");			log(e.text);		}				protected function onMediaError(e:ErrorEvent):void{			_eventDispatcher.dispatchEvent(new GenericDataEvent(MEDIA_LOAD_ERROR, {error:e.text}));		}				protected function log(logItem:*, ...args):void{			var category:Array = [this.toString().replace("[object ", "").replace("]", "")];			Logger.log(logItem,category,true);						if (args.length > 0) {				Logger.log(args,[category[0]+"..."],true);			}		}				public function destroy():void {			//			contentLoaderInfo.removeEventListener(Event.COMPLETE, onLoaded);			if (_urlRequest && _urlRequest.url && _urlRequest.url.split(".").pop().toLowerCase() === "swf") {				unloadAndStop();			} else {				unload(); 			}			removeEventListener(IOErrorEvent.IO_ERROR, onIOError);			contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);			removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);			if (_urlLoader) {				_urlLoader.removeEventListener(Event.COMPLETE, onRawDataLoaded);				_urlLoader.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);				_urlLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);				_urlLoader = null;			}			_content = null;		}	}}