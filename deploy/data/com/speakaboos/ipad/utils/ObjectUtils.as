package com.speakaboos.ipad.utils {	import flash.utils.ByteArray;			/**	 * @author stevewarren	 */	public class ObjectUtils {				// will copy any depth nested flash Array and Object including objects of type Class, which are treated like simple types		// author hudsonansley		public static function copyObj(obj:*):* {			return copyObjRec(obj);		}		private static function copyObjRec(obj:*):* {			var result:*;			if (obj && (typeof obj === "object")) {				if (obj.hasOwnProperty("length")) { // array					result = [];					for (var i:int; i<obj.length; i++) result.push(copyObjRec(obj[i]));				} else { // only handles base flash objects, but handles Class objects, which the byteArray technique does not					if (obj.toString() === "[object Object]") {						result = {};						for (var nm:String in obj) result[nm] = copyObjRec(obj[nm]);					} else {// just take it						result = obj;					}				}			} else {				result = obj;			}			return result;		}		// this fails for class objects 				public static function copy(value:Object):Object		{			var buffer:ByteArray = new ByteArray();			buffer.writeObject(value);			buffer.position = 0;			return buffer.readObject();		}				public static function arrayToObject(arr:Array):Object{			var obj:Object = new Object();			for (var prop:Object in arr){				obj["prop_"+formatNumWithZeroes(prop,3)] = arr[prop];			}			return obj;		}				public static function formatNumWithZeroes(num:*,numPlaces:int):String{			var numString:String = String(num);			while (numString.length < numPlaces){				numString = "0"+numString;			}			return numString;					}				public static function getGenericObject(obj:Object):Object{			//trace("getGenericObject");			var objectCopy:Object = copy(obj);						for(var prop:Object in objectCopy){				//trace("\t prop:"+prop);			}						return objectCopy;		}		//		public static function listProps(obj:Object):String{ //TODO: re-write this, as is should not work as expected//			var output:String = "";//			trace("listProp value:"+obj);//			//			var copy:Object = copy(obj);//			var checkArray:Array = ["Number", "Boolean", "String", "Date", "int"]; //these should be all lower case, and list is not correct: number,boolean,function,string,xml,undefined//			for(var prop:Object in copy){//				//trace("typeof:"+typeof(copy[prop]));//				if (ArrayUtils.arrayContainsValue(checkArray, typeof(copy[prop]))){ //indexof should work here...//					trace("\t prop:"+prop+", type:"+typeof(copy[prop])+", value:"+copy[prop]);//					output += "\t prop:"+prop+", type:"+typeof(copy[prop])+", value:"+copy[prop];//				}else{//					//recurse object//					trace("----------------------------------------");//					trace("recurse prop:"+prop+", type:"+typeof(copy[prop]));//					listProps(obj[prop]);//				}//			}//			return output;//		}				public static function getObjectFromString(str:String):Object{			var data:Object  = new Object();			var dataArray:Array = str.split("|");			var dataProps:Array;			var propName:String;			var prop:String;			for (var i:int=0; i<dataArray.length; i++){				dataProps = dataArray[i].split(":");				propName = dataProps.shift();				prop = unescape(dataProps.join(":"));				data[propName] = prop;			}						return data;		}				public static function getStringFromObject(obj:Object):String{			var returnString:String="";			for (var prop:Object in obj){				returnString += prop + ":" + obj[prop] + "|";			}						returnString.substr(0,returnString.length-2);						return returnString;					}				public static function compareObject(obj1:Object,obj2:Object):Boolean{		    var buffer1:ByteArray = new ByteArray();		    buffer1.writeObject(obj1);		    var buffer2:ByteArray = new ByteArray();		    buffer2.writeObject(obj2);		 		    // compare the lengths		    var size:uint = buffer1.length;		    if (buffer1.length == buffer2.length) {		        buffer1.position = 0;		        buffer2.position = 0;		 		        // then the bits		        while (buffer1.position < size) {		            var v1:int = buffer1.readByte();		            if (v1 != buffer2.readByte()) {		                return false;		            }		        }    		        return true;                        		    }		    return false;		}  		public static function compareObjectProps(obj1:Object,obj2:Object):Boolean{ //TODO: see listProps comments		    			    	if (typeof(obj1) != typeof(obj2)) return false;		    			    	switch (typeof(obj1)){		    		case "Number":		    		case "Boolean":		    		case "String":		    		case "Date":		    		case "int":		    			if (obj1 != obj2) return false;		    			break;		    		default: //"Object"		    			for (var prop:Object in obj1){		    				return compareObjectProps(obj1[prop],obj2[prop]);		    			}		    	}		    			    return true;		    		}  						public static function getSafeParameter(paramObj:Object, name:String, defaultValue:String=""):String		{			//safely retrieve a value from an object.			//if it doesn't exist, return a default value						// Check if parameter exists			if(paramObj.hasOwnProperty(name) && paramObj[name] != "")				return paramObj[name];                     			else				return defaultValue;		}				public static function methodExists(thisObj:Object, thisMethod:String):Boolean{			try{				if(thisObj.hasOwnProperty(thisMethod) && (thisObj[thisMethod] is Function))					{return true;}				else					{return false;}			}			catch(err:Error){				return false;			}						return false;						}							}}