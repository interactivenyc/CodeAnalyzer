package com.speakaboos.ipad.models.services{	import com.milkmangames.nativeextensions.ios.StoreKit;	import com.milkmangames.nativeextensions.ios.StoreKitProduct;	import com.milkmangames.nativeextensions.ios.events.StoreKitErrorEvent;	import com.milkmangames.nativeextensions.ios.events.StoreKitEvent;	import com.speakaboos.core.service.error.StoreKitServiceError;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.events.SubscriptionEvents;	import com.speakaboos.ipad.models.data.UserProfile;	import com.speakaboos.ipad.models.data.product.TransactionMode;
		//import flash.debugger.enterDebugger;		public class StoreKitService extends CoreService	{		private static var _instance:StoreKitService;		private var _storeKit:StoreKit;		private var _storeEnabled:Boolean = false;		//private const IS_SANDBOX:Boolean = true;  /* TODO switch to false for Production version */		//private const APP_ID:String = "";		private var _transactionMode:String = TransactionMode.STANDARD;				public function StoreKitService( enforcer:SingletonEnforcer ){			super();			log("constructor");			}				public static function get instantiated():Boolean {return Boolean(_instance)};				public static function getInstance():StoreKitService {			if( _instance == null ) {				_instance = new StoreKitService( new SingletonEnforcer() );			}			return _instance;		}		public static function destroySingleton():void {			if (instantiated) _instance.destroy();		}				public function enable():String{						log("StoreKit Version: " + StoreKit.VERSION);						if(isEnabled())				return StoreKitServiceError.STOREKIT_ENABLED;						if(!isSupported()){				//destroy();				_storeKit = null;				return StoreKitServiceError.NOT_SUPPORTED;			}						//try creating the storeKit singleton			try{				_storeKit=StoreKit.create();			}			catch(e:Error){				//storeKit was already created				_storeKit = StoreKit.storeKit;				log("Error: storekit was already created");								//remove listeners that were already added, to avoid adding them twice				removeStoreKitListeners();			}						if(!StoreKit.storeKit.isStoreKitAvailable()){				log("this device has purchases disabled.");				setStoreEnabled(false);				//destroy();				return StoreKitServiceError.PURCHASES_DISABLED;							} else {								addStoreKitListeners();				setStoreEnabled(true);				return StoreKitServiceError.STOREKIT_ENABLED;				}					}						private function setStoreEnabled(b:Boolean):void{			_storeEnabled = b;		}				private function addStoreKitListeners():void {							log("Device can make purchases");						// Listen for events. 			StoreKit.storeKit.addEventListener(StoreKitEvent.PRODUCT_DETAILS_LOADED, receiveStoreKitEvent);			StoreKit.storeKit.addEventListener(StoreKitEvent.PURCHASE_SUCCEEDED, receiveStoreKitEvent);			StoreKit.storeKit.addEventListener(StoreKitEvent.PURCHASE_CANCELLED, receiveStoreKitEvent);			StoreKit.storeKit.addEventListener(StoreKitEvent.TRANSACTIONS_RESTORED, receiveStoreKitEvent);						// adding error events. 			StoreKit.storeKit.addEventListener(StoreKitErrorEvent.PRODUCT_DETAILS_FAILED, receiveStoreKitErrorEvent);			StoreKit.storeKit.addEventListener(StoreKitErrorEvent.PURCHASE_FAILED, receiveStoreKitErrorEvent);			StoreKit.storeKit.addEventListener(StoreKitErrorEvent.TRANSACTION_RESTORE_FAILED, receiveStoreKitErrorEvent);					}						private function removeStoreKitListeners():void{			// removing event listeners. 			StoreKit.storeKit.removeEventListener(StoreKitEvent.PRODUCT_DETAILS_LOADED, receiveStoreKitEvent);			StoreKit.storeKit.removeEventListener(StoreKitEvent.PURCHASE_SUCCEEDED, receiveStoreKitEvent);			StoreKit.storeKit.removeEventListener(StoreKitEvent.PURCHASE_CANCELLED, receiveStoreKitEvent);			StoreKit.storeKit.removeEventListener(StoreKitEvent.TRANSACTIONS_RESTORED, receiveStoreKitEvent);			// removing error events. 			StoreKit.storeKit.removeEventListener(StoreKitErrorEvent.PRODUCT_DETAILS_FAILED, receiveStoreKitErrorEvent);			StoreKit.storeKit.removeEventListener(StoreKitErrorEvent.PURCHASE_FAILED, receiveStoreKitErrorEvent);			StoreKit.storeKit.removeEventListener(StoreKitErrorEvent.TRANSACTION_RESTORE_FAILED, receiveStoreKitErrorEvent);					}				override public function destroy():void{			log("Destroying StoreKit");			if (_storeKit) {				removeStoreKitListeners();				setStoreEnabled(false);								_storeKit = null;				StoreKit.storeKit.dispose();							}			if (_instance) _instance = null;						super.destroy();		}								private function isEnabled():Boolean{			return (_storeKit != null && _storeEnabled);		}						public function isSupported():Boolean{			return StoreKit.isSupported();		}						private function setMode(m:String):void{			_transactionMode = m;		}				/*			accessors		*/		/*		public function isSandBox():Boolean{			return IS_SANDBOX;		}		*/					/************************************************************************/		/*			core logic		*/		/************************************************************************/				public function getProductDetails(prodIDs:Vector.<String>):void{			if(!isEnabled()){				log("storekit not enabled");				_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_PRODUCT_DETAILS_FAILED,{messageData:"Failed to load iTunes Product Details"}));				}			else{				log("Obtaining product details from iTunes");				StoreKit.storeKit.loadProductDetails(prodIDs);			}		}						public function createSubscription(userProfile:UserProfile, productId:String):void {						log("createSubscription called. User id: "+ userProfile.user_id + "Product id: "+productId);						setMode(TransactionMode.STANDARD);			if(isEnabled()) {									log("Switching StoreKit to manual mode");				StoreKit.storeKit.setManualTransactionMode(true);				log("Calling storeKit.purchaseProduct");				StoreKit.storeKit.purchaseProduct(productId);											} else {				log("StoreKit not enabled");				_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_SUBSCRIBE_FAILED, {messageData:"StoreKit not enabled"}));				}					}					/*		public function createSpeakITunesSubscription(e:StoreKitEvent,userProfile:UserProfile):void {  			SubscriptionService.getInstance().createITunesSubscription(userProfile,e);					}			*/						public function restoreTransactions():void{			if(!isEnabled()){				log("StoreKit is not enabled...exiting.");				return;			}						setMode(TransactionMode.RESTORE);			StoreKit.storeKit.setManualTransactionMode(false);			StoreKit.storeKit.restoreTransactions();							}				public function finishManualTransaction(transID:String):void{			log("finishManualTransaction");			if(!isEnabled()){				log("StoreKit is not enabled...exiting.");				return;			}						log("StoreKit is enabled...proceeding.");			//enterDebugger();			StoreKit.storeKit.manualFinishTransaction(transID);					}					/*********************************************************************/		/*			Handlers for iTunes events				*/		/*********************************************************************/				private function onProductDetails(e:StoreKitEvent):void{						log("products loaded.");						/*			returns:			StoreKitProduct(productId=com.speakaboos.ipad.suba,title=Speakaboos Subscription,description=Subscription to Speakaboos content.,price=4.99,localizedPrice=$4.99,localeId=en_US@currency=USD)			*/						log(e.validProducts);						var _productList:Vector.<StoreKitProduct> = e.validProducts;			var i:int = 0;			log("iterating over products: ");			for each(var p:StoreKitProduct in _productList){				log("StoreKitProduct " +  ++i + ":");				log(p);			}						// if any of the product ids we tried to pass in were not found on the server,			// we won't be able to buy them so something is wrong.			if (e.invalidProductIds!=null)			{				if (e.invalidProductIds.length>0)				{					log("[ERR]: these products not valid:"+e.invalidProductIds.join(","));					//return;				}			}						if(i>0)				_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_PRODUCT_DETAILS_LOADED,{messageData:_productList}));				else				_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_PRODUCT_DETAILS_FAILED,{messageData:"No valid products found."}));						}						private function onProductDetailsFailed(e:StoreKitErrorEvent):void{			log("onProductDetailsFailed");			_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_PRODUCT_DETAILS_FAILED,{messageData:"Failed to load iTunes Product Details"}));						}						private function onTransactionFailed(e:StoreKitErrorEvent):void{			log("onTransactionFailed");			_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_SUBSCRIBE_FAILED, {messageData:"Failed to complete transaction.  ErrorID: " + e.errorId}));			}				private function onTransactionRestoreFailed(e:StoreKitErrorEvent):void{			log("onTransactionRestoreFailed");			_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_FAILED, {messageData:"Failed to complete transaction.  ErrorID: " + e.errorId}));			}						private function onGetSpeakaboosProductIDs():void{			//called when the service call to Speakaboos returns the list of productIDs					}						/*********************************************************************		 * STOREKIT EVENT HANDLING		 *********************************************************************/				public function receiveStoreKitEvent(e:StoreKitEvent):void{			log("receiveStoreKitEvent type:"+e.type);			switch(e.type){								//APPLICATION EVENTS				case StoreKitEvent.PRODUCT_DETAILS_LOADED:					onProductDetails(e);					break;								case StoreKitEvent.PURCHASE_SUCCEEDED:					/*						this event is called in two different scenarios:						1. Normal transaction is completed						2. As part of a series of restore purchases transactions (it may be called numerous times, once for each transaction)					*/					log("Purchase Succeeded: mode -> " + _transactionMode);					if(_transactionMode == TransactionMode.RESTORE){						_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_TRANSACTION_RESTORE_SUCCEEDED, {messageData:e}));					}						else{						_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_SUBSCRIBE_SUCCEEDED, {messageData:e}));					}										break;								case StoreKitEvent.PURCHASE_CANCELLED:					_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_SUBSCRIBE_CANCELLED, {messageData:e}));											break;								case StoreKitEvent.TRANSACTIONS_RESTORED:					setMode(TransactionMode.STANDARD);					_eventDispatcher.dispatchEvent(new GenericDataEvent(SubscriptionEvents.ITUNES_TRANSACTIONS_RESTORED, {messageData:e}));											break;			}		}						public function receiveStoreKitErrorEvent(e:StoreKitErrorEvent):void{			log("receiveStoreKitEvent type:"+e.type);			switch(e.type){								//APPLICATION EVENTS				case StoreKitErrorEvent.PRODUCT_DETAILS_FAILED:					onProductDetailsFailed(e);					break;												case StoreKitErrorEvent.PURCHASE_FAILED:					onTransactionFailed(e);						break;								case StoreKitErrorEvent.TRANSACTION_RESTORE_FAILED:					onTransactionRestoreFailed(e);					break;													}					}			}}class SingletonEnforcer {	public function SingletonEnforcer():void {}}