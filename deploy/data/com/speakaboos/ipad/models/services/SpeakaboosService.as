package com.speakaboos.ipad.models.services{	import com.speakaboos.ipad.controller.AppController;	import com.speakaboos.ipad.events.AppEvents;	import com.speakaboos.ipad.events.DBEvents;	import com.speakaboos.ipad.events.GenericDataEvent;	import com.speakaboos.ipad.models.data.Category;	import com.speakaboos.ipad.models.data.Character;	import com.speakaboos.ipad.models.data.Promos;	import com.speakaboos.ipad.models.data.Story;	
//	import com.speakaboos.ipad.utils.ObjectUtils;	//TODO: remove cacheData of stories and categories when they are processed.	public class SpeakaboosService extends CacheDataService	{		private static var _instance:SpeakaboosService;		private var _dataReady:Boolean = false;		private var _categories:Array;		private var _characters:Array;		private var _promoData:Promos;		private var _category:Category = null;		private var _storiesBySlug:Object;		private var _categoriesBySlug:Object;		private var _savedStories:Object;		private var _curGenericDataLoadEvent:String;		final public function get savedStoryCount():int {						var result:int = 0;			if (_dataReady) {				var story:Story;				for (var slug:String in _savedStories) { 					story = _storiesBySlug[slug];					if (story && story.saved) result++;				}				//test - not needed in release//				var testResult:int = 0;//				for (slug in _storiesBySlug) {//					story = _storiesBySlug[slug];//					if (story && story.saved) testResult++;//				}//				if (result !== testResult) throw new Error("bad saved story count using _savedStories: "+result+" should match "+ testResult);			}			log("* savedStoryCount: "+result);			return result;		}				final public function get savedStories():Array {			var result:Array = [];			var story:Story;			for (var slug:String in _savedStories) {				story = _storiesBySlug[slug];				if (story) result.push(story);			}			result.sortOn("id");			return result;		}				final public function get stories():Array {			var result:Array = [];			var slugs:Array = [];			var story:Story;			var i:int;			if (_category) {				var slug:String;				slugs = _category.storySlugs.concat();				if (AppController.inOfflineMode || AppController.inRestrictedMode) {					var savedStories:Object = _category.savedStories;					i = slugs.length;					while (i--) { //put saved stories in front						slug = slugs[i];						if (savedStories[slug]) {							story = _storiesBySlug[slug] as Story;							if (story) result.push(story);							slugs.splice(i, 1);						}					}				}			}			result.sortOn("id"); //sort the saved list by id (saved order)			for (i = 0; i < slugs.length; i++) {				result.push( _storiesBySlug[slugs[i]]);			}//			log("get stories", _category.storySlugs.length, result.length, slugs.length);			return result;		};		final public function get categories():Array {return _categories};		final public function get characters():Array {return _characters};		final public function get promos():Promos {return _promoData};//TODO: process if saved				//private var _storiesByCategory:Array;						public function SpeakaboosService( enforcer:SingletonEnforcer ) {			super();			if( enforcer == null ) throw new Error( "SpeakaboosService is a singleton class and should only be instantiated via its static getInstance() method" );		}				public static function get instantiated():Boolean {return Boolean(_instance)};				public static function getInstance():SpeakaboosService {			if( _instance == null ) {				_instance = new SpeakaboosService( new SingletonEnforcer() );				_instance.init();			}			return _instance;		}		public static function destroySingleton():void {			if (instantiated) _instance.destroy();		}				final override protected function init():void{			super.init();			resetValues();			_eventDispatcher.addEventListener(AppEvents.USER_DATA_UPDATED, receiveEvent);			_eventDispatcher.addEventListener(DBEvents.STORY_ADDED_TO_DB, receiveEvent);			_eventDispatcher.addEventListener(DBEvents.DELETE_STORY_SUCCESS, receiveEvent);			_eventDispatcher.addEventListener(DBEvents.DELETE_SAVED_STORIES_SUCCESS, receiveEvent);		}				final public function resetValues():void{			_storiesBySlug = {};			_categoriesBySlug = {};			_savedStories = {};			_category = null;			_categories = [];			_characters = [];		}				final public function processPreloadedData():void {			var catData:Object = getPreloadedData(GET_CATEGORIES_METHOD);			var items:Array;			var category:Category;			var i:int;			items = catData.categories.on_book;			for (i = 0; i<items.length; i++) {				category = new Category(items[i]);				_categories.push(category);				_categoriesBySlug[category.slug] = category;				processPreloadedStoriesByCategory(category);			}			var character:Character;			items = catData.categories.in_wheel;			for (i = 0; i<items.length; i++) {				character = new Character(items[i]);				_characters.push(character);				_categoriesBySlug[character.slug] = character;				processPreloadedStoriesByCategory(character);			}			items = catData.categories.promo_board;			_promoData = new Promos(items); 						resetCategoryStorySavedCount(onInitialSavedStoryUpdate);		}		// this should not create a new story object for dupe stories... need to re-order slug lists according to id when saved data loaded...		final private function processPreloadedStoriesByCategory(category:Category):void {			var data:Object = getPreloadedData(GET_STORIES_BY_CATEGORY_METHOD, category.slug);			var stories:Array = data.stories;			var slug:String;			category.storySlugs.length = 0;			var i:int;			for (i = 0; i<stories.length; i++) {				slug = stories[i].slug;				if (!_storiesBySlug[slug]) {					_storiesBySlug[slug] = new Story(stories[i]);				}				category.storySlugs.push(slug);			}		}				final public function getGenericData(slug:String):void {//			log("getGenericData "+preloadComplete+", "+slug+", "+SLUG_SUBTYPE);			_curGenericDataLoadEvent = GENERIC_DATA_METHOD + slug;			getData(onGenericDataLoaded, GENERIC_DATA_METHOD, true, slug, SLUG_SUBTYPE);		}				final private function onGenericDataLoaded(data:Object):void		{//			log("onGenericDataLoaded _curGenericDataLoadEvent:"+_curGenericDataLoadEvent+", data.length:"+data.length);			_eventDispatcher.dispatchEvent(new GenericDataEvent(_curGenericDataLoadEvent, data));		}		final public function getStoryBySlug(slug:String):Story{//			log("getStoryBySlug: "+slug);			return _storiesBySlug[slug];		}				final public function getCategoryBySlug(slug:String):Category{//			log("getCategoryBySlug: "+slug);			return _categoriesBySlug[slug];		}				final public function setCategoryBySlug(slug:String):void{//			log("setCategoryBySlug: "+slug);			_category = _categoriesBySlug[slug];		}						final private function resetCategoryStorySavedCount(callback:Function):void {			log("resetCategoryStorySavedCount");			_eventDispatcher.addEventListener(DBEvents.SAVED_STORY_RESULTS, callback);			StoryDbService.getInstance().querySavedStories(AppController.getInstance().checkUserHasFullAccess(), AppController.FREE_STORY_LIMIT);		}		final private function clearAllSavedMarks():void {//			log("clearAllSavedMarks");			var slug:String;			for (slug in _savedStories) {				markStorySaved(slug, false);			}			// test for proper clear, could be removed for final build//			var cleared:Boolean = true;//			var catSlug:String//			for (catSlug in _categoriesBySlug) {//				log("checking cat saved "+catSlug+", "+_categoriesBySlug[catSlug].savedStoryCount);//				if (_categoriesBySlug[catSlug].savedStoryCount) {//					cleared = false;//					break;//				}//				for (slug in _categoriesBySlug[catSlug].savedStories) {//					cleared = false;//					break;//				}//				if (!cleared) break;//			}//			if (cleared) {//				for (slug in _savedStories) {//					cleared = false;//					break;//				}//			}//			if (!cleared) throw new Error("clearAllSavedMarks failed catSlug:"+catSlug+", slug:"+slug);		}		//		final private function clearSavedStoriesByCategory(cat:Category):void{//			if(cat && cat.savedStories != null){//				for(var slug:String in cat.savedStories){//					var s:Story = getStoryBySlug(slug);//					if(s && s.saved){//						s.saved = false;//					}//				}//				cat.savedStories = {};//			}//		}//						final private function onInitialSavedStoryUpdate(e:GenericDataEvent):void {			log("onInitialSavedStoryUpdate");			_eventDispatcher.removeEventListener(DBEvents.SAVED_STORY_RESULTS, onInitialSavedStoryUpdate);			updateSavedStories(e.data.storyQueryResults);			_dataReady = true;			_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.PRELOAD_COMPLETE), 200);//			_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.USER_DATA_UPDATE_PROCESSED), 300);		}				final private function onUpdateSavedStories(e:GenericDataEvent):void{			log("onUpdateSavedStories");			_eventDispatcher.removeEventListener(DBEvents.SAVED_STORY_RESULTS, onUpdateSavedStories);			updateSavedStories(e.data.storyQueryResults);			_eventDispatcher.dispatchEvent(new GenericDataEvent(AppEvents.USER_DATA_UPDATE_PROCESSED));		}				final private function updateSavedStories(storyQueryResults):void {			clearAllSavedMarks();			log( "updateSavedStories savedStoryCount after clear: "+savedStoryCount);			if (storyQueryResults) {				var story:Story;				var storyObj:Object;				var slug:String;				for (var i:int=0; i<storyQueryResults.length; i++) {					storyObj = storyQueryResults[i];					slug = storyObj.slug;					story = _storiesBySlug[slug] as Story;					log("saved story slug: "+slug+", "+story);					if (story) { // check in case saved story was deleted from CMS						story.id = storyObj.id;						markStorySaved(slug);					}				}			}		}				final private function onDeleteStory(slug:String):void{			log("onDeleteStory "+slug);			markStorySaved(slug, false);		}				final private function onDeleteAllStories():void{			log("onDeleteAllStories");			clearAllSavedMarks();		}				// need to mark either for just one category or the whole list so can just process one or all				final private function markStorySaved(slug:String, saved:Boolean = true):void {			var story:Story = _storiesBySlug[slug];			if (story) {				if (saved) {					_savedStories[slug] = true;				} else {					if (_savedStories[slug]) {						delete _savedStories[slug];					}				}				story.saved = saved;//				log("markStorySaved "+saved+", '"+slug+"'");				var cat:Category;				var j:int;				var catSlugs:Array = story.categories;				for (var i:int = 0; i < catSlugs.length; i++) {					cat = _categoriesBySlug[catSlugs[i]];					if (saved) {						cat.savedStories[slug] = true;					} else {						if (cat.savedStories[slug]) {							delete cat.savedStories[slug];						}					}				}			} else {				log("attempt to mark story "+slug+" saved = "+saved+", but lookup failed");				//this could happen if saved story was deleted from CMS			}		}				final public function get category():Category{			//log("get category: "+_category.slug);			return _category;		}				final public function set category(category:Category):void{			//log("set category: "+_category.slug);			_category = category;		}						final private function receiveEvent(e:GenericDataEvent):void{			log("receiveEvent type:"+e.type);			//log(new Date());						switch(e.type){				//APPLICATION EVENTS				case DBEvents.STORY_ADDED_TO_DB:					markStorySaved(e.data.story.slug);					break;				case DBEvents.DELETE_STORY_SUCCESS:					onDeleteStory(e.data.story.slug);					break;				case DBEvents.DELETE_SAVED_STORIES_SUCCESS:					onDeleteAllStories();					break;								case AppEvents.USER_DATA_UPDATED:					if (_preloadComplete) resetCategoryStorySavedCount(onUpdateSavedStories);					break;			}		}				final public function categoryHasSavedStories(cat:Category = null):Boolean {			var result:Boolean = false;			if (!cat) cat = _category;			if (cat) result = cat.savedStoryCount > 0;			return result;
		}				final override public function destroy():void {			_eventDispatcher.removeEventListener(AppEvents.USER_DATA_UPDATED, receiveEvent);			_eventDispatcher.removeEventListener(DBEvents.STORY_ADDED_TO_DB, receiveEvent);			_eventDispatcher.removeEventListener(DBEvents.DELETE_STORY_SUCCESS, receiveEvent);			_eventDispatcher.removeEventListener(DBEvents.DELETE_SAVED_STORIES_SUCCESS, receiveEvent);			_eventDispatcher.removeEventListener(DBEvents.SAVED_STORY_RESULTS, onUpdateSavedStories);			_eventDispatcher.removeEventListener(DBEvents.SAVED_STORY_RESULTS, onInitialSavedStoryUpdate);			_categories.length = 0;			_categories = null;			_characters.length = 0;			_characters = null;			if (_promoData) _promoData.reset();			if (_category) _category.reset();			_category = null;			var prop:String;			for (prop in _storiesBySlug) {				_storiesBySlug[prop].reset();				delete _storiesBySlug[prop];			}			_storiesBySlug = null;			for (prop in _categoriesBySlug) {				_categoriesBySlug[prop].reset();				delete _categoriesBySlug[prop];			}			_categoriesBySlug = null;			for (prop in _categoriesBySlug) {				delete _savedStories[prop];			}			_savedStories = null;			_curGenericDataLoadEvent = null;			_instance = null;			super.destroy();		}	}}class SingletonEnforcer {	public function SingletonEnforcer():void {}}